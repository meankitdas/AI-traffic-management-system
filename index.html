<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Simulation - Bhubaneswar</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- Hugging Face Transformers.js for pre-trained models -->
    <script type="module">
      import {
        pipeline,
        env,
      } from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0";

      // Configure for browser usage
      env.allowRemoteModels = true;
      env.allowLocalModels = false;

      // Make available globally
      window.transformers = { pipeline, env };
      window.transformersLoaded = false;

      // Initialize the models when page loads
      window.addEventListener("DOMContentLoaded", async () => {
        try {
          // Load a lightweight regression model for traffic prediction
          window.trafficPredictor = await pipeline(
            "feature-extraction",
            "Xenova/all-MiniLM-L6-v2"
          );
          window.transformersLoaded = true;
          console.log("ü§ó Hugging Face models loaded successfully!");

          // Update status
          if (document.getElementById("neural-status")) {
            document.getElementById("neural-status").textContent =
              "AI Status: Hugging Face Pre-trained Model Ready ü§ó";
          }

          // Update AI display when Hugging Face models are loaded
          setTimeout(function () {
            updateAIDisplay();
          }, 500);
        } catch (error) {
          console.error("Failed to load Hugging Face models:", error);
          window.transformersLoaded = false;
        }
      });
    </script>
    <style>
      #map {
        height: 600px;
        width: 100%;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      h1 {
        text-align: center;
      }
      #controls {
        text-align: center;
        margin: 10px;
      }
      #neural-status {
        background: #f0f0f0;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
      }
      #log {
        background: #f9f9f9;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        max-height: 150px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
        border: 1px solid #ddd;
      }
      .vehicle-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .traffic-light-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .intersection-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .loading {
        text-align: center;
        padding: 20px;
        background: #e8f4fd;
        border-radius: 5px;
        margin: 10px;
      }
      .error {
        background: #ffe6e6;
        border: 1px solid #ff9999;
        color: #cc0000;
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
      .success {
        background: #e6ffe6;
        border: 1px solid #99ff99;
        color: #006600;
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <h1>AI Traffic Simulation System for Bhubaneswar</h1>
    <div id="map"></div>
    <div id="controls">
      <input type="file" id="geojsonInput" accept=".geojson" /><label
        >Upload GeoJSON File</label
      ><br />
      <label
        >Simulation Speed:
        <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1"
      /></label>
      <button id="play">Play</button>
      <button id="pause">Pause</button>
      <button id="reset">Reset</button>
      <button id="reduceVehicles">Reduce Vehicles</button>
      <button id="collectData">Collect Data</button>
      <button id="trainNN">Train Neural Network</button>
    </div>
    <div id="neural-status">AI Status: Initializing AI Models...</div>
    <div
      id="ai-confidence"
      style="
        background: #e8f5e8;
        padding: 8px;
        margin: 10px;
        border-radius: 5px;
        font-size: 14px;
      "
    >
      AI Confidence: <span id="confidence-value">Loading...</span> | Model:
      <span id="model-type">Hugging Face + TensorFlow</span> | Predictions:
      <span id="prediction-count">0</span>
    </div>
    <div
      id="traffic-legend"
      style="
        background: #f0f8ff;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        font-size: 12px;
      "
    >
      <strong>üö¶ Traffic Congestion Legend:</strong><br />
      <span style="color: #00ff00; font-weight: bold">‚óè Green</span> - Free Flow
      (Fast) | <span style="color: #ffff00; font-weight: bold">‚óè Yellow</span> -
      Light Traffic |
      <span style="color: #ffa500; font-weight: bold">‚óè Orange</span> - Moderate
      | <span style="color: #ff0000; font-weight: bold">‚óè Red</span> - Heavy
      Traffic |
      <span style="color: #8b0000; font-weight: bold">‚óè Dark Red</span> - Severe
      Congestion (Stopped)
    </div>
    <div id="log">Simulation Log:</div>
    <script>
      var map = L.map("map").setView([20.272, 85.824], 13); // Bhubaneswar center
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      }).addTo(map);

      var roadsLayer = L.layerGroup().addTo(map);
      var intersectionsLayer = L.layerGroup().addTo(map);
      var vehiclesLayer = L.layerGroup().addTo(map);

      var allRoads = [];
      var allIntersections = [];
      var trafficLights = {};
      var vehicles = [];
      var simulationInterval;
      var isPlaying = false;
      var speed = 1;

      // Road Network Graph for realistic vehicle movement
      var roadNetwork = {
        nodes: new Map(), // Intersection points
        edges: new Map(), // Roads connecting intersections
        roadConnections: new Map(), // Which roads connect to which roads
      };

      // Vehicle routing and pathfinding
      var routeCache = new Map(); // Cache for calculated routes

      // Road congestion tracking
      var roadCongestionLevels = {}; // Store congestion level for each road
      var roadUpdateCounter = 0;

      // Neural Network for Traffic Management
      var neuralNetwork = null;
      var trafficData = [];
      var isTraining = false;

      // Road Network Graph Functions
      function buildRoadNetwork() {
        roadNetwork.nodes.clear();
        roadNetwork.edges.clear();
        roadNetwork.roadConnections.clear();

        // Build nodes (intersections) from road endpoints
        allRoads.forEach((road, roadIndex) => {
          const coords = road.geometry;
          const startPoint = coords[0];
          const endPoint = coords[coords.length - 1];

          const startKey = `${startPoint[0].toFixed(6)},${startPoint[1].toFixed(
            6
          )}`;
          const endKey = `${endPoint[0].toFixed(6)},${endPoint[1].toFixed(6)}`;

          // Add nodes if they don't exist
          if (!roadNetwork.nodes.has(startKey)) {
            roadNetwork.nodes.set(startKey, {
              position: startPoint,
              connectedRoads: [],
              isIntersection: false,
            });
          }
          if (!roadNetwork.nodes.has(endKey)) {
            roadNetwork.nodes.set(endKey, {
              position: endPoint,
              connectedRoads: [],
              isIntersection: false,
            });
          }

          // Add road to connected roads for both nodes
          roadNetwork.nodes.get(startKey).connectedRoads.push({
            roadIndex: roadIndex,
            direction: "outgoing",
            otherEnd: endKey,
          });
          roadNetwork.nodes.get(endKey).connectedRoads.push({
            roadIndex: roadIndex,
            direction: "incoming",
            otherEnd: startKey,
          });

          // Store edge (road) information
          roadNetwork.edges.set(roadIndex, {
            startNode: startKey,
            endNode: endKey,
            geometry: coords,
            length: calculatePathLength(coords),
            roadData: road,
          });
        });

        // Mark intersections (nodes with more than 2 connections)
        roadNetwork.nodes.forEach((node, nodeKey) => {
          if (node.connectedRoads.length > 2) {
            node.isIntersection = true;
          }
        });

        // Build road connections for pathfinding
        buildRoadConnections();

        console.log(
          `üõ£Ô∏è Road network built: ${roadNetwork.nodes.size} nodes, ${roadNetwork.edges.size} edges`
        );
      }

      function buildRoadConnections() {
        // For each intersection, connect all incoming roads to all outgoing roads
        roadNetwork.nodes.forEach((node, nodeKey) => {
          if (node.isIntersection) {
            const incomingRoads = node.connectedRoads.filter(
              (r) => r.direction === "incoming"
            );
            const outgoingRoads = node.connectedRoads.filter(
              (r) => r.direction === "outgoing"
            );

            incomingRoads.forEach((inRoad) => {
              if (!roadNetwork.roadConnections.has(inRoad.roadIndex)) {
                roadNetwork.roadConnections.set(inRoad.roadIndex, []);
              }

              outgoingRoads.forEach((outRoad) => {
                if (inRoad.roadIndex !== outRoad.roadIndex) {
                  roadNetwork.roadConnections.get(inRoad.roadIndex).push({
                    toRoadIndex: outRoad.roadIndex,
                    viaIntersection: nodeKey,
                    turnType: calculateTurnType(inRoad, outRoad, node.position),
                  });
                }
              });
            });
          }
        });
      }

      function calculateTurnType(inRoad, outRoad, intersection) {
        // Calculate turn type based on road directions
        const inRoadData = roadNetwork.edges.get(inRoad.roadIndex);
        const outRoadData = roadNetwork.edges.get(outRoad.roadIndex);

        if (!inRoadData || !outRoadData) return "straight";

        // Get direction vectors
        const inDirection = getDirectionVector(inRoadData.geometry, true); // towards intersection
        const outDirection = getDirectionVector(outRoadData.geometry, false); // away from intersection

        // Calculate angle between directions
        const angle = calculateAngleBetweenVectors(inDirection, outDirection);

        if (angle < 30) return "straight";
        else if (angle < 120) return "right";
        else if (angle < 240) return "u-turn";
        else return "left";
      }

      function getDirectionVector(geometry, reverse = false) {
        if (geometry.length < 2) return [0, 0];

        let start, end;
        if (reverse) {
          start = geometry[geometry.length - 1];
          end = geometry[geometry.length - 2];
        } else {
          start = geometry[0];
          end = geometry[1];
        }

        return [end[0] - start[0], end[1] - start[1]];
      }

      function calculateAngleBetweenVectors(v1, v2) {
        const dot = v1[0] * v2[0] + v1[1] * v2[1];
        const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
        const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);

        if (mag1 === 0 || mag2 === 0) return 0;

        const cosAngle = dot / (mag1 * mag2);
        const angle =
          Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);

        return angle;
      }

      // Vehicle Pathfinding
      function findRoute(fromRoadIndex, toRoadIndex, maxHops = 5) {
        const cacheKey = `${fromRoadIndex}-${toRoadIndex}`;
        if (routeCache.has(cacheKey)) {
          return routeCache.get(cacheKey);
        }

        if (fromRoadIndex === toRoadIndex) {
          return [fromRoadIndex];
        }

        // Simple BFS pathfinding
        const visited = new Set();
        const queue = [
          { roadIndex: fromRoadIndex, path: [fromRoadIndex], hops: 0 },
        ];

        while (queue.length > 0) {
          const { roadIndex, path, hops } = queue.shift();

          if (hops >= maxHops) continue;

          if (visited.has(roadIndex)) continue;
          visited.add(roadIndex);

          const connections = roadNetwork.roadConnections.get(roadIndex) || [];

          for (const connection of connections) {
            const newPath = [...path, connection.toRoadIndex];

            if (connection.toRoadIndex === toRoadIndex) {
              routeCache.set(cacheKey, newPath);
              return newPath;
            }

            if (!visited.has(connection.toRoadIndex)) {
              queue.push({
                roadIndex: connection.toRoadIndex,
                path: newPath,
                hops: hops + 1,
              });
            }
          }
        }

        // No route found, return direct path
        const fallbackRoute = [fromRoadIndex];
        routeCache.set(cacheKey, fallbackRoute);
        return fallbackRoute;
      }

      // Initialize AI System with Hugging Face Pre-trained Models
      async function initNeuralNetwork() {
        try {
          // Wait for Hugging Face models to load
          let attempts = 0;
          while (!window.transformersLoaded && attempts < 30) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            attempts++;
          }

          if (!window.transformersLoaded) {
            throw new Error(
              "Hugging Face models failed to load within timeout"
            );
          }

          // Initialize additional specialized models for traffic analysis
          try {
            // Load a time series forecasting model for traffic prediction
            window.timeSeriesModel = await window.transformers.pipeline(
              "feature-extraction",
              "Xenova/distilbert-base-uncased"
            );

            console.log("üö¶ Traffic prediction models loaded successfully");
          } catch (modelError) {
            console.warn(
              "Advanced models not available, using fallback:",
              modelError
            );
          }

          // Enhanced TensorFlow model with more features for traffic optimization
          neuralNetwork = tf.sequential({
            layers: [
              tf.layers.dense({
                inputShape: [8], // Increased input features for better prediction
                units: 64,
                activation: "relu",
                name: "traffic_dense_1",
              }),
              tf.layers.dropout({ rate: 0.3 }),
              tf.layers.dense({
                units: 32,
                activation: "relu",
                name: "traffic_dense_2",
              }),
              tf.layers.dropout({ rate: 0.2 }),
              tf.layers.dense({
                units: 16,
                activation: "relu",
                name: "traffic_dense_3",
              }),
              tf.layers.dense({ units: 4, activation: "sigmoid" }), // Output: [green_time, sync_offset, priority, flow_rate]
            ],
          });

          neuralNetwork.compile({
            optimizer: tf.train.adam(0.001),
            loss: "meanSquaredError",
            metrics: ["mae"],
          });

          document.getElementById("neural-status").textContent =
            "AI Status: Trained!";
          console.log("üß† Advanced AI traffic system initialized successfully");

          // Set initial AI confidence values
          lastAIConfidence = 0.85;
          predictionCount = 1;
          updateAIDisplay();
        } catch (error) {
          console.error("Failed to initialize AI system:", error);
          document.getElementById("neural-status").textContent =
            "AI Status: Error - " + error.message;

          // Fallback to basic TensorFlow model
          try {
            neuralNetwork = tf.sequential({
              layers: [
                tf.layers.dense({
                  inputShape: [6],
                  units: 16,
                  activation: "relu",
                }),
                tf.layers.dense({ units: 4, activation: "sigmoid" }),
              ],
            });
            neuralNetwork.compile({
              optimizer: tf.train.adam(0.01),
              loss: "meanSquaredError",
            });
            document.getElementById("neural-status").textContent =
              "AI Status: Fallback Model Ready";

            // Set initial AI confidence values for fallback
            lastAIConfidence = 0.65;
            predictionCount = 1;
            updateAIDisplay();
          } catch (fallbackError) {
            console.error("Even fallback model failed:", fallbackError);
          }
        }
      }

      // Traffic Light Synchronization System
      var syncGroups = {};
      var globalPhaseOffset = 0;

      function createSyncGroups() {
        // Group nearby traffic lights for synchronization
        var lightPositions = Object.keys(trafficLights).map((key) => ({
          key: key,
          pos: trafficLights[key].position,
          light: trafficLights[key],
        }));

        var groupId = 0;
        lightPositions.forEach((light1, i) => {
          if (!light1.light.syncGroup) {
            var group = [light1];
            light1.light.syncGroup = groupId;

            // Find nearby lights within 0.01 degrees
            lightPositions.forEach((light2, j) => {
              if (i !== j && !light2.light.syncGroup) {
                var distance = Math.sqrt(
                  Math.pow(light1.pos[0] - light2.pos[0], 2) +
                    Math.pow(light1.pos[1] - light2.pos[1], 2)
                );

                if (distance < 0.01) {
                  // Within sync range
                  group.push(light2);
                  light2.light.syncGroup = groupId;
                }
              }
            });

            syncGroups[groupId] = group;
            groupId++;
          }
        });
      }

      function synchronizeTrafficLights() {
        globalPhaseOffset += 0.1 * speed;

        Object.values(syncGroups).forEach((group, groupIndex) => {
          var groupPhase = (globalPhaseOffset + groupIndex * 20) % 80; // 80 second cycle

          group.forEach((lightObj, index) => {
            var light = lightObj.light;
            var phaseDelay = index * 5; // 5 second delay between lights in group
            var lightPhase = (groupPhase + phaseDelay) % 80;

            // Update light state based on synchronized phase
            var newState;
            var newIcon;

            if (lightPhase < 30) {
              newState = "green";
              newIcon = L.divIcon({
                html: "üü¢",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            } else if (lightPhase < 35) {
              newState = "yellow";
              newIcon = L.divIcon({
                html: "üü°",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            } else {
              newState = "red";
              newIcon = L.divIcon({
                html: "üî¥",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            }

            if (light.state !== newState) {
              light.state = newState;
              light.marker.setIcon(newIcon);
            }
          });
        });
      }

      // Advanced AI Prediction using Hugging Face Models
      async function predictOptimalTiming(
        density,
        congestion,
        avgSpeed,
        timeOfDay,
        weatherFactor,
        historicalFlow
      ) {
        if (!neuralNetwork) {
          // Increment prediction count even for fallback
          predictionCount++;
          return {
            green: 30,
            sync: 0,
            priority: 0.5,
            flow: 1.0,
            aiConfidence: 0.3, // Higher confidence for fallback
          };
        }

        try {
          // Enhanced prediction with Hugging Face models
          if (window.transformersLoaded && window.trafficPredictor) {
            // Create a textual representation of traffic state for the model
            const trafficContext = `Traffic density: ${density.toFixed(
              2
            )}, congestion: ${congestion.toFixed(2)}, speed: ${avgSpeed.toFixed(
              1
            )}km/h, time: ${timeOfDay}:00, weather: ${(
              weatherFactor * 100
            ).toFixed(0)}%, flow: ${historicalFlow}`;

            try {
              // Get embeddings from the pre-trained model
              const embeddings = await window.trafficPredictor(trafficContext);

              // Extract meaningful features from embeddings
              const features = embeddings.data || embeddings;
              let avgEmbedding = 0;
              for (let i = 0; i < Math.min(8, features.length); i++) {
                avgEmbedding += features[i];
              }
              avgEmbedding = avgEmbedding / Math.min(8, features.length);

              // Use embeddings to enhance traditional prediction
              const embeddingInfluence = Math.max(
                0.1,
                Math.min(2.0, Math.abs(avgEmbedding))
              );

              // Enhanced input with embeddings
              const enhancedInput = tf.tensor2d([
                [
                  density / 10,
                  congestion / 5,
                  avgSpeed / 50,
                  timeOfDay / 24,
                  weatherFactor,
                  historicalFlow / 100,
                  embeddingInfluence, // Hugging Face embedding influence
                  Math.sin((timeOfDay * Math.PI) / 12), // Time cyclical feature
                ],
              ]);

              const prediction = neuralNetwork.predict(enhancedInput);
              const result = await prediction.data();

              enhancedInput.dispose();
              prediction.dispose();

              // Enhanced results with AI insights
              predictionCount++; // Increment for successful Hugging Face prediction
              return {
                green: Math.max(
                  10,
                  Math.min(90, result[0] * 80 + embeddingInfluence * 5)
                ), // 10-90 seconds with AI influence
                sync: result[1] * 15, // 0-15 second offset
                priority: Math.max(
                  0.2,
                  Math.min(0.95, result[2] + embeddingInfluence * 0.1)
                ), // AI-enhanced priority
                flow: Math.max(
                  0.3,
                  Math.min(1.0, result[3] + embeddingInfluence * 0.2)
                ), // AI-enhanced flow
                aiConfidence: Math.max(0.7, embeddingInfluence), // Higher confidence from AI model
              };
            } catch (hfError) {
              console.warn(
                "Hugging Face prediction failed, using fallback:",
                hfError
              );
              // Fall through to traditional prediction
            }
          }

          // Traditional TensorFlow prediction (fallback)
          const input = tf.tensor2d([
            [
              density / 10,
              congestion / 5,
              avgSpeed / 50,
              timeOfDay / 24,
              weatherFactor,
              historicalFlow / 100,
              Math.sin((timeOfDay * Math.PI) / 12), // Time cyclical feature
              (density * congestion) / 50, // Interaction feature
            ],
          ]);

          const prediction = neuralNetwork.predict(input);
          const result = await prediction.data();

          input.dispose();
          prediction.dispose();

          predictionCount++; // Increment for successful TensorFlow prediction
          return {
            green: Math.max(15, Math.min(60, result[0] * 60)), // 15-60 seconds
            sync: result[1] * 10, // 0-10 second offset
            priority: result[2], // 0-1 priority factor
            flow: result[3], // 0-1 flow efficiency
            aiConfidence: 0.6, // Medium-high confidence for TensorFlow
          };
        } catch (error) {
          console.error("AI prediction error:", error);
          // Increment prediction count for error case
          predictionCount++;
          return {
            green: 30,
            sync: 0,
            priority: 0.5,
            flow: 1.0,
            aiConfidence: 0.2, // Slightly higher confidence
          };
        }
      }

      // Collect training data
      function collectTrafficData() {
        if (trafficData.length > 1000) trafficData.shift(); // Keep last 1000 records

        var avgDensity = 0;
        var lightCount = Object.keys(trafficLights).length;

        if (lightCount > 0) {
          avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / lightCount;
        }

        var avgCongestion = 0;
        var avgSpeed = 25; // Default speed

        if (vehicles.length > 0) {
          // Simplified congestion calculation for performance
          avgCongestion = Math.min(5, vehicles.length / 50); // Estimate based on vehicle density
          avgSpeed =
            vehicles.reduce((sum, v) => sum + v.speed * 1000, 0) /
            vehicles.length;
        }

        var timeOfDay = new Date().getHours();
        var weatherFactor = 1.0; // Could be dynamic based on weather API
        var historicalFlow = vehicles.length;

        // Calculate efficiency (lower density and congestion = higher efficiency)
        var efficiency = Math.max(0.1, 1 - avgDensity / 10 - avgCongestion / 8);

        // Enhanced features for AI model
        var timeFeature = Math.sin((timeOfDay * Math.PI) / 12);
        var interactionFeature = (avgDensity * avgCongestion) / 50;

        // More realistic target values based on current conditions
        var optimalGreen = Math.max(0.3, Math.min(0.9, 0.4 + avgDensity / 15));
        var optimalSync = Math.random() * 0.6 + 0.2; // 0.2 to 0.8
        var optimalPriority = Math.max(0.4, Math.min(0.9, efficiency + 0.1));

        // Enhanced training data with more features for Hugging Face integration
        trafficData.push({
          input: [
            avgDensity / 10,
            avgCongestion / 5,
            avgSpeed / 50,
            timeOfDay / 24,
            weatherFactor,
            historicalFlow / 100,
            timeFeature, // Time cyclical feature
            interactionFeature, // Density-congestion interaction
          ],
          output: [efficiency, optimalGreen, optimalSync, optimalPriority],
        });

        // Log data collection progress
        if (trafficData.length % 10 === 0) {
          updateLog(`üìä Collected ${trafficData.length} training samples`);
        }
      }

      // Generate training data quickly for demonstration
      function generateTrainingData() {
        updateLog("üß† Generating training data...");

        // Generate synthetic training data based on current simulation state
        for (var i = trafficData.length; i < 100; i++) {
          var syntheticDensity = Math.random() * 10;
          var syntheticCongestion = Math.random() * 5;
          var syntheticSpeed = 20 + Math.random() * 30;
          var syntheticTimeOfDay = Math.random() * 24;
          var syntheticWeather = 0.8 + Math.random() * 0.4;
          var syntheticFlow = Math.random() * 100;

          // Calculate realistic efficiency based on conditions
          var efficiency = Math.max(
            0.1,
            1 - syntheticDensity / 15 - syntheticCongestion / 10
          );
          var optimalGreen = Math.min(0.9, 0.3 + syntheticDensity / 20);
          var optimalSync = Math.random() * 0.8;
          var optimalPriority = Math.min(0.9, efficiency + 0.1);

          trafficData.push({
            input: [
              syntheticDensity / 10,
              syntheticCongestion / 5,
              syntheticSpeed / 50,
              syntheticTimeOfDay / 24,
              syntheticWeather,
              syntheticFlow / 100,
            ],
            output: [efficiency, optimalGreen, optimalSync, optimalPriority],
          });
        }

        updateLog(`‚úÖ Generated ${trafficData.length} training samples`);
      }

      // Train Neural Network
      async function trainNeuralNetwork() {
        // Prevent multiple concurrent training sessions
        if (isTraining) {
          updateLog(
            '<div class="error">‚ö†Ô∏è Training already in progress. Please wait...</div>'
          );
          return;
        }

        if (!neuralNetwork) {
          document.getElementById("neural-status").textContent =
            "Neural Network not initialized";
          return;
        }

        if (trafficData.length < 50) {
          updateLog(`üìä Current data: ${trafficData.length}/50 samples`);
          generateTrainingData(); // Generate data if we don't have enough
        }

        isTraining = true;

        // Update UI to show training in progress
        const trainButton = document.getElementById("trainNN");
        trainButton.textContent = "Training... ‚è≥";
        trainButton.disabled = true;

        document.getElementById("neural-status").textContent =
          "Training Neural Network...";
        updateLog("üß† Starting neural network training...");

        try {
          // Validate training data
          if (trafficData.length === 0) {
            throw new Error("No training data available");
          }

          const inputs = tf.tensor2d(trafficData.map((d) => d.input));
          const outputs = tf.tensor2d(trafficData.map((d) => d.output));

          updateLog(`üéØ Training with ${trafficData.length} samples...`);

          await neuralNetwork.fit(inputs, outputs, {
            epochs: 30, // Reduced epochs for faster training
            batchSize: Math.min(10, Math.floor(trafficData.length / 4)), // Dynamic batch size
            validationSplit: 0.2,
            shuffle: true, // Shuffle data for better training
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                if (epoch % 5 === 0) {
                  // Update every 5 epochs
                  const progress = Math.round((epoch / 30) * 100);
                  document.getElementById(
                    "neural-status"
                  ).textContent = `Training: ${progress}% (Epoch ${epoch}/30, Loss: ${logs.loss.toFixed(
                    4
                  )})`;
                  updateLog(
                    `üìà Training progress: ${progress}% - Loss: ${logs.loss.toFixed(
                      4
                    )}`
                  );
                }
              },
              onTrainEnd: () => {
                updateLog("‚úÖ Training completed successfully!");
              },
            },
          });

          // Clean up tensors to prevent memory leaks
          inputs.dispose();
          outputs.dispose();

          document.getElementById("neural-status").textContent =
            "Neural Network: Trained Successfully ‚úÖ";
          updateLog(
            '<div class="success">üéâ Neural Network training completed! AI optimization is now active.</div>'
          );
        } catch (error) {
          console.error("Training error:", error);
          let errorMessage = error.message;

          // Provide user-friendly error messages
          if (errorMessage.includes("fit() call is ongoing")) {
            errorMessage =
              "Another training session is already running. Please wait for it to complete.";
          } else if (errorMessage.includes("tensor")) {
            errorMessage =
              "Data format error. Please try collecting new training data.";
          }

          document.getElementById("neural-status").textContent =
            "Training Failed: " + errorMessage;
          updateLog(
            `<div class="error">‚ùå Training failed: ${errorMessage}</div>`
          );
        } finally {
          isTraining = false;

          // Reset UI
          const trainButton = document.getElementById("trainNN");
          trainButton.textContent = "Train Neural Network";
          trainButton.disabled = false;

          updateLog("üîÑ Training session ended. Ready for new training.");
        }
      }

      function loadGeoJSON(urlOrFile) {
        // Clear existing data
        roadsLayer.clearLayers();
        intersectionsLayer.clearLayers();
        vehiclesLayer.clearLayers();
        allRoads = [];
        allIntersections = [];
        trafficLights = {};
        vehicles = [];
        syncGroups = {};

        // Show loading indicator
        updateLog('<div class="loading">üîÑ Loading GeoJSON data...</div>');

        if (urlOrFile instanceof File) {
          var reader = new FileReader();
          reader.onload = function (e) {
            try {
              var data = JSON.parse(e.target.result);
              processGeoJSON(data);
            } catch (error) {
              console.error("Error parsing uploaded file:", error);
              updateLog(
                '<div class="error">‚ùå Error parsing uploaded file. Please check the file format.</div>'
              );
            }
          };
          reader.onerror = function () {
            updateLog(
              '<div class="error">‚ùå Error reading uploaded file.</div>'
            );
          };
          reader.readAsText(urlOrFile);
        } else {
          fetch(urlOrFile)
            .then((response) => {
              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                );
              }
              return response.json();
            })
            .then((data) => {
              updateLog(
                '<div class="success">‚úÖ GeoJSON loaded successfully!</div>'
              );
              processGeoJSON(data);
            })
            .catch((error) => {
              console.error("Error loading GeoJSON:", error);
              updateLog(
                `<div class="error">‚ùå Error loading GeoJSON: ${error.message}</div>`
              );

              // Try to create a fallback simulation with demo data
              updateLog(
                '<div class="loading">üîÑ Creating demo traffic simulation...</div>'
              );
              createDemoSimulation();
            });
        }
      }

      function createDemoSimulation() {
        // Create a realistic demo road network for Bhubaneswar with more roads
        var demoRoads = [
          // Major arterial roads
          [
            [20.272, 85.82],
            [20.275, 85.825],
            [20.278, 85.83],
            [20.281, 85.835],
          ],
          [
            [20.27, 85.815],
            [20.272, 85.82],
            [20.274, 85.825],
            [20.276, 85.83],
          ],
          [
            [20.268, 85.822],
            [20.27, 85.827],
            [20.272, 85.832],
            [20.274, 85.837],
          ],
          [
            [20.275, 85.818],
            [20.277, 85.823],
            [20.279, 85.828],
            [20.281, 85.833],
          ],
          [
            [20.265, 85.825],
            [20.268, 85.83],
            [20.271, 85.835],
            [20.274, 85.84],
          ],

          // Cross streets for realistic grid
          [
            [20.269, 85.815],
            [20.269, 85.825],
            [20.269, 85.835],
          ],
          [
            [20.273, 85.817],
            [20.273, 85.827],
            [20.273, 85.837],
          ],
          [
            [20.277, 85.819],
            [20.277, 85.829],
            [20.277, 85.839],
          ],

          // Ring roads
          [
            [20.266, 85.816],
            [20.27, 85.82],
            [20.274, 85.824],
            [20.278, 85.828],
            [20.282, 85.832],
          ],
          [
            [20.28, 85.818],
            [20.276, 85.822],
            [20.272, 85.826],
            [20.268, 85.83],
            [20.264, 85.834],
          ],

          // Additional connecting roads
          [
            [20.271, 85.816],
            [20.275, 85.821],
            [20.279, 85.826],
          ],
          [
            [20.267, 85.823],
            [20.271, 85.828],
            [20.275, 85.833],
          ],
          [
            [20.273, 85.819],
            [20.277, 85.824],
            [20.281, 85.829],
          ],
        ];

        demoRoads.forEach((roadCoords, index) => {
          var road = L.polyline(roadCoords, { color: "#666", weight: 3 });
          roadsLayer.addLayer(road);

          // Classify roads by length and position for major junction identification
          var roadLength = calculatePathLength(roadCoords);
          var roadType, vehicleCount;

          // More selective classification - only longest roads are "primary"
          if (roadLength > 0.025) {
            roadType = "primary";
            vehicleCount = Math.floor(Math.random() * 30) + 20; // High traffic
          } else if (roadLength > 0.02) {
            roadType = "secondary";
            vehicleCount = Math.floor(Math.random() * 20) + 10; // Medium traffic
          } else if (roadLength > 0.015) {
            roadType = "tertiary";
            vehicleCount = Math.floor(Math.random() * 12) + 6; // Low traffic
          } else {
            roadType = "residential";
            vehicleCount = Math.floor(Math.random() * 8) + 2; // Very low traffic
          }

          // Mark major arterial roads (first few longest roads)
          if (index < 3 && roadLength > 0.02) {
            roadType = "trunk"; // Major arterial designation
            vehicleCount += 10; // Boost traffic for major roads
          }

          allRoads.push({
            geometry: roadCoords,
            properties: {
              road_id: `demo_${index}`,
              highway: roadType,
              vehicle_count: vehicleCount,
            },
            layer: road,
          });

          // Add vehicles to demo road
          addVehiclesToRoad(roadCoords, {
            vehicle_count: vehicleCount,
          });

          // Use intelligent traffic light placement (much fewer lights)
          addTrafficLight(roadCoords, {
            highway: roadType,
            vehicle_count: vehicleCount,
          });
        });

        createSyncGroups();
        buildRoadNetwork(); // Build road network for realistic vehicle movement

        var lightCount = Object.keys(trafficLights).length;
        var lightDensity = ((lightCount / allRoads.length) * 100).toFixed(1);

        updateLog(
          `<div class="success">‚úÖ Demo simulation created: ${allRoads.length} roads, ${vehicles.length} vehicles, ${lightCount} traffic lights (${lightDensity}% road coverage - major junctions only)</div>`
        );
        setTimeout(startSimulation, 1000); // Auto-start after 1 second
      }

      function processGeoJSON(data) {
        var roadCount = 0;
        var trafficLightCount = 0;
        var pointCount = 0;

        // Check what type of data we have
        var hasLineStrings = data.features.some(
          (f) => f.geometry.type === "LineString"
        );
        var hasPoints = data.features.some((f) => f.geometry.type === "Point");

        updateLog(
          `Processing ${data.features.length} features. LineStrings: ${hasLineStrings}, Points: ${hasPoints}`
        );

        if (!hasLineStrings && hasPoints) {
          // If we only have points, create synthetic roads between nearby points
          updateLog(
            "No LineString roads found. Creating synthetic road network from points..."
          );
          createSyntheticRoads(data.features);
          setTimeout(startSimulation, 1000); // Auto-start after 1 second
          return;
        }

        data.features.forEach((feature) => {
          if (
            feature.geometry.type === "LineString" &&
            feature.properties.highway &&
            feature.properties.road_id
          ) {
            var coords = feature.geometry.coordinates.map((c) => [c[1], c[0]]);
            var road = L.polyline(coords, { color: "gray", weight: 3 });
            roadsLayer.addLayer(road);
            allRoads.push({
              geometry: coords,
              properties: feature.properties,
              layer: road,
            });
            roadCount++;

            // Add vehicles to roads
            addVehiclesToRoad(coords, feature.properties);

            // Add traffic lights (VERY restrictive - major junctions only)
            if (coords.length > 3 && calculatePathLength(coords) > 0.015) {
              // Only longer roads with multiple points
              var lightCountBefore = Object.keys(trafficLights).length;
              addTrafficLight(coords, feature.properties);
              var lightCountAfter = Object.keys(trafficLights).length;
              if (lightCountAfter > lightCountBefore) {
                trafficLightCount++;
              }
            }
          } else if (feature.geometry.type === "Point") {
            // Process traffic signals and intersections from point data
            processPointFeature(feature);
            pointCount++;
          }
        });

        // Create synchronization groups after loading all lights
        createSyncGroups();
        buildRoadNetwork(); // Build road network for realistic vehicle movement

        updateLog(
          `<div class="success">‚úÖ Loaded ${roadCount} roads, ${pointCount} points, ${trafficLightCount} traffic lights (${
            Object.keys(syncGroups).length
          } sync groups), ${vehicles.length} vehicles</div>`
        );
        if (vehicles.length > 0) {
          setTimeout(startSimulation, 1000); // Auto-start if we have vehicles
        }
      }

      function createSyntheticRoads(pointFeatures) {
        var points = pointFeatures
          .filter(
            (f) =>
              f.geometry.type === "Point" && f.properties.road_id !== undefined
          )
          .map((f) => ({
            coords: [f.geometry.coordinates[1], f.geometry.coordinates[0]], // lat, lng
            properties: f.properties,
          }))
          .slice(0, 50); // Limit to 50 points for performance

        // Create roads between nearby points
        for (var i = 0; i < points.length; i++) {
          for (var j = i + 1; j < points.length; j++) {
            var distance = calculateDistance(
              points[i].coords,
              points[j].coords
            );
            if (distance < 0.02 && Math.random() < 0.3) {
              // 2km max distance, 30% chance
              var roadCoords = [points[i].coords, points[j].coords];
              var road = L.polyline(roadCoords, {
                color: "#666",
                weight: 2,
                opacity: 0.7,
              });
              roadsLayer.addLayer(road);
              allRoads.push({
                geometry: roadCoords,
                properties: {
                  road_id: `synthetic_${i}_${j}`,
                  highway: "synthetic",
                  vehicle_count: Math.floor(Math.random() * 50) + 10,
                },
                layer: road,
              });

              // Add vehicles to synthetic road
              addVehiclesToRoad(roadCoords, {
                vehicle_count: Math.floor(Math.random() * 20) + 5,
              });
            }
          }
        }

        // Add traffic lights only at major intersections (much reduced)
        points.slice(0, 8).forEach((point) => {
          // VERY restrictive - only actual traffic signals and major junctions
          if (
            point.properties.highway === "traffic_signals" ||
            (point.properties.junction === "yes" &&
              point.properties.highway === "primary" &&
              Math.random() < 0.2) || // Only primary road junctions with 20% chance
            Math.random() < 0.03 // Reduced from 0.1 to 0.03 (3% chance for random)
          ) {
            addTrafficLightAtPoint(point.coords);
          }
        });

        buildRoadNetwork(); // Build road network for realistic vehicle movement

        updateLog(
          `<div class="success">‚úÖ Created ${allRoads.length} synthetic roads from ${points.length} points with ${vehicles.length} vehicles</div>`
        );
        if (vehicles.length > 0) {
          setTimeout(startSimulation, 1000); // Auto-start if we have vehicles
        }
      }

      function addVehiclesToRoad(coords, properties) {
        var vehicleCount = properties.vehicle_count || 0;

        if (Math.random() < 0.8) {
          // Increase to 80% of roads get vehicles for realistic traffic
          var roadLength = calculatePathLength(coords);
          var vehiclesPerRoad = Math.min(
            12, // Increased vehicles per road for better traffic density
            Math.max(2, Math.floor(roadLength * 100 + vehicleCount * 0.15)) // Higher density
          );

          for (var v = 0; v < vehiclesPerRoad; v++) {
            var point = getPointAlongLine(coords, Math.random());
            if (point) {
              // Indian traffic mix with realistic speeds (much faster)
              var vehicleTypes = [
                {
                  icon: "üöó",
                  speed: 0.015,
                  type: "car",
                  color: "#ff6b6b",
                  size: 4,
                },
                {
                  icon: "üèçÔ∏è",
                  speed: 0.025,
                  type: "bike",
                  color: "#4ecdc4",
                  size: 3,
                },
                {
                  icon: "üöå",
                  speed: 0.012,
                  type: "bus",
                  color: "#45b7d1",
                  size: 6,
                },
                {
                  icon: "üõ∫",
                  speed: 0.018,
                  type: "auto",
                  color: "#f9ca24",
                  size: 3,
                },
                {
                  icon: "üöö",
                  speed: 0.013,
                  type: "truck",
                  color: "#6c5ce7",
                  size: 5,
                },
                {
                  icon: "üõ¥",
                  speed: 0.022,
                  type: "scooter",
                  color: "#a0e7e5",
                  size: 2,
                },
                {
                  icon: "üöï",
                  speed: 0.017,
                  type: "taxi",
                  color: "#feca57",
                  size: 4,
                },
                {
                  icon: "üèçÔ∏è",
                  speed: 0.028,
                  type: "motorcycle",
                  color: "#ff9ff3",
                  size: 3,
                },
              ];

              var vehicleType = vehicleTypes[Math.floor(Math.random() * 8)];

              // Create more realistic vehicle markers with different sizes
              var vehicleIcon = L.circleMarker(point, {
                radius: vehicleType.size,
                fillColor: vehicleType.color,
                color: "#333",
                weight: 1,
                opacity: 0.9,
                fillOpacity: 0.8,
              });

              // Add turn signal indicator (initially hidden)
              var turnSignalIcon = L.circleMarker(point, {
                radius: vehicleType.size + 2,
                fillColor: "transparent",
                color: "#ffff00",
                weight: 2,
                opacity: 0,
                fillOpacity: 0,
              });

              vehiclesLayer.addLayer(vehicleIcon);
              vehiclesLayer.addLayer(turnSignalIcon);

              // Generate random destination for realistic routing
              const destinationRoadIndex = Math.floor(
                Math.random() * allRoads.length
              );
              const currentRoadIndex = allRoads.length - 1;

              vehicles.push({
                marker: vehicleIcon,
                turnSignalMarker: turnSignalIcon,
                path: coords,
                pos: Math.random(),
                speed: vehicleType.speed * (0.7 + Math.random() * 0.6), // More speed variation
                baseSpeed: vehicleType.speed, // Store original speed for congestion adjustments
                type: vehicleType.type,
                aggressiveness: 0.3 + Math.random() * 0.7, // More varied driving styles
                lane: Math.random() < 0.5 ? "left" : "right", // Lane preference
                lastUpdate: 0, // For smoother movement
                roadIndex: currentRoadIndex, // Track which road this vehicle is on
                // Realistic routing information
                route: null, // Will be calculated when needed
                routeIndex: 0, // Current position in route
                destinationRoadIndex: destinationRoadIndex,
                atIntersection: false,
                turningDirection: null, // 'left', 'right', 'straight', 'u-turn'
                waitingAtIntersection: false,
                intersectionWaitTime: 0,
                // Enhanced behavior properties
                turnSignal: null, // 'left', 'right', null
                turnSignalTimer: 0, // Timer for blinking turn signals
                followingDistance: 0.001 + Math.random() * 0.002, // Distance to maintain behind other vehicles
                maxSpeed: vehicleType.speed * (1.2 + Math.random() * 0.3), // Maximum speed this vehicle can achieve
                currentDirection: null, // Current movement direction vector
                targetDirection: null, // Target direction for smooth turning
              });

              if (vehicles.length >= maxVehicles) break;
            }
          }
        }
      }

      function addTrafficLight(coords, properties) {
        // VERY RESTRICTIVE: Only major junctions and arterial roads get traffic lights
        var roadLength = calculatePathLength(coords);
        var vehicleCount = properties?.vehicle_count || 0;
        var roadType = properties?.highway || "unknown";

        // Major junction criteria - much more restrictive
        var shouldAddLight = false;

        // Only major arterial roads get consideration
        if (roadLength > 0.025) {
          // Very long roads (major arterials only) - 30% chance (reduced from 60%)
          shouldAddLight = Math.random() < 0.3;
        } else if (roadLength > 0.02) {
          // Long roads - 15% chance (reduced from 30%)
          shouldAddLight = Math.random() < 0.15;
        } else if (roadLength > 0.015) {
          // Medium roads - 8% chance (reduced from 15%)
          shouldAddLight = Math.random() < 0.08;
        } else {
          // Small roads/lanes - NO traffic lights (was 5%)
          shouldAddLight = false;
        }

        // High traffic volume override (more restrictive)
        if (vehicleCount > 15) {
          // Only very high traffic roads get priority - 40% chance (reduced from 80%)
          shouldAddLight = Math.random() < 0.4;
        } else if (vehicleCount > 10) {
          // High traffic - 20% chance
          shouldAddLight = Math.random() < 0.2;
        }

        // Road type priority (only major road types)
        if (roadType === "primary" || roadType === "trunk") {
          shouldAddLight = shouldAddLight && Math.random() < 0.5; // Further reduce by 50%
        } else if (roadType === "secondary") {
          shouldAddLight = shouldAddLight && Math.random() < 0.3; // Further reduce by 70%
        } else if (roadType === "residential" || roadType === "tertiary") {
          shouldAddLight = false; // No lights on residential/small roads
        }

        if (shouldAddLight) {
          var midPoint = coords[Math.floor(coords.length / 2)];
          addTrafficLightAtPoint(midPoint);
        }
      }

      function addTrafficLightAtPoint(point) {
        var trafficLightIcon = L.divIcon({
          html: '<div style="font-size: 18px;">üö•</div>',
          className: "traffic-light-icon",
          iconSize: [25, 25],
          iconAnchor: [12, 12],
        });
        var light = L.marker(point, { icon: trafficLightIcon });
        intersectionsLayer.addLayer(light);
        trafficLights[point.join(",")] = {
          marker: light,
          state: "green",
          timer: 30 + Math.random() * 20,
          position: point,
          syncGroup: null,
        };
      }

      function processPointFeature(feature) {
        var coords = [
          feature.geometry.coordinates[1],
          feature.geometry.coordinates[0],
        ];

        if (feature.properties.highway === "traffic_signals") {
          addTrafficLightAtPoint(coords);
        } else if (feature.properties.junction === "yes") {
          // Add intersection marker
          var intersectionIcon = L.divIcon({
            html: '<div style="font-size: 16px;">‚≠ï</div>',
            className: "intersection-icon",
            iconSize: [20, 20],
            iconAnchor: [10, 10],
          });
          var marker = L.marker(coords, { icon: intersectionIcon });
          intersectionsLayer.addLayer(marker);
        }
      }

      function calculateDistance(point1, point2) {
        var R = 6371; // Earth's radius in km
        var dLat = ((point2[0] - point1[0]) * Math.PI) / 180;
        var dLng = ((point2[1] - point1[1]) * Math.PI) / 180;
        var a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((point1[0] * Math.PI) / 180) *
            Math.cos((point2[0] * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      loadGeoJSON("bhubaneswar_traffic_flow.geojson");

      // Calculate traffic density around intersection
      function calculateTrafficDensity(position) {
        var density = 0;
        var radius = 0.01;

        vehicles.forEach((vehicle) => {
          var vehiclePos = vehicle.marker.getLatLng();
          var distance = Math.sqrt(
            Math.pow(position[0] - vehiclePos.lat, 2) +
              Math.pow(position[1] - vehiclePos.lng, 2)
          );
          if (distance < radius) {
            density++;
          }
        });
        return density;
      }

      // Calculate road congestion levels and update colors
      function updateRoadCongestion() {
        roadUpdateCounter++;

        allRoads.forEach((road, roadIndex) => {
          var roadId = `road_${roadIndex}`;
          var vehiclesOnRoad = 0;
          var totalSpeed = 0;
          var stoppedVehicles = 0;

          // Count vehicles on this specific road
          vehicles.forEach((vehicle) => {
            if (vehicle.roadIndex === roadIndex) {
              vehiclesOnRoad++;
              totalSpeed += vehicle.speed;

              // Check if vehicle is nearly stopped (very slow)
              if (vehicle.speed < 0.002) {
                stoppedVehicles++;
              }
            }
          });

          // Calculate congestion metrics
          var roadLength = calculatePathLength(road.geometry);
          var vehicleDensity = vehiclesOnRoad / Math.max(0.1, roadLength * 100); // vehicles per unit length
          var avgSpeed =
            vehiclesOnRoad > 0 ? totalSpeed / vehiclesOnRoad : 0.02;
          var stoppedRatio =
            vehiclesOnRoad > 0 ? stoppedVehicles / vehiclesOnRoad : 0;

          // Determine congestion level (0 = free, 1 = light, 2 = moderate, 3 = heavy, 4 = severe)
          var congestionLevel = 0;

          if (stoppedRatio > 0.7 || vehicleDensity > 8) {
            congestionLevel = 4; // Severe congestion (dark red)
          } else if (stoppedRatio > 0.4 || vehicleDensity > 5) {
            congestionLevel = 3; // Heavy congestion (red)
          } else if (stoppedRatio > 0.2 || vehicleDensity > 3) {
            congestionLevel = 2; // Moderate congestion (yellow)
          } else if (vehicleDensity > 1.5) {
            congestionLevel = 1; // Light congestion (orange)
          } else {
            congestionLevel = 0; // Free flow (green)
          }

          // Store congestion level
          roadCongestionLevels[roadId] = {
            level: congestionLevel,
            density: vehicleDensity,
            avgSpeed: avgSpeed,
            stoppedRatio: stoppedRatio,
            vehicleCount: vehiclesOnRoad,
          };

          // Update road color based on congestion level
          var roadColor;
          var roadWeight = 3;

          switch (congestionLevel) {
            case 4: // Severe congestion
              roadColor = "#8B0000"; // Dark red
              roadWeight = 5;
              break;
            case 3: // Heavy congestion
              roadColor = "#FF0000"; // Red
              roadWeight = 4;
              break;
            case 2: // Moderate congestion
              roadColor = "#FFA500"; // Orange/Yellow
              roadWeight = 4;
              break;
            case 1: // Light congestion
              roadColor = "#FFFF00"; // Yellow
              roadWeight = 3;
              break;
            default: // Free flow
              roadColor = "#00FF00"; // Green
              roadWeight = 3;
          }

          // Update the road layer color
          if (road.layer) {
            road.layer.setStyle({
              color: roadColor,
              weight: roadWeight,
              opacity: 0.8,
            });
          }
        });
      }

      // Get road congestion level for a vehicle's current road
      function getRoadCongestionLevel(roadIndex) {
        var roadId = `road_${roadIndex}`;
        return (
          roadCongestionLevels[roadId] || {
            level: 0,
            density: 0,
            avgSpeed: 0.02,
          }
        );
      }

      // Realistic Traffic System with Road Network Navigation
      function updateVehicleAgents() {
        if (vehicles.length === 0) return;

        var now = Date.now();
        var batchSize = Math.min(50, Math.ceil(vehicles.length / 3));
        var startIndex = (updateCounter * batchSize) % vehicles.length;
        var endIndex = Math.min(startIndex + batchSize, vehicles.length);
        var updates = [];

        for (var i = startIndex; i < endIndex; i++) {
          var vehicle = vehicles[i];

          // Skip some vehicles for performance (only 10% now)
          if (Math.random() < 0.1) continue;

          var currentPos = vehicle.marker.getLatLng();
          vehicle.lastUpdate = now;

          // Update vehicle route if needed
          updateVehicleRoute(vehicle);

          // Check if vehicle is at intersection
          var intersectionStatus = checkIntersectionStatus(vehicle);

          // Handle intersection logic
          if (intersectionStatus.atIntersection) {
            handleIntersectionBehavior(vehicle, intersectionStatus);
          }

          // Add realistic lane changing behavior
          addLaneChangeLogic(vehicle, intersectionStatus);

          // Calculate movement speed based on various factors
          var movementData = calculateVehicleMovement(
            vehicle,
            intersectionStatus
          );

          // Update vehicle position
          var newPosition = updateVehiclePosition(vehicle, movementData);

          if (newPosition) {
            updates.push({ vehicle: vehicle, point: newPosition });
          }
        }

        // Apply all updates at once for smooth animation
        updates.forEach(function (update) {
          update.vehicle.marker.setLatLng(update.point);

          // Update turn signal position and visibility
          if (update.vehicle.turnSignalMarker) {
            update.vehicle.turnSignalMarker.setLatLng(update.point);
            updateTurnSignal(update.vehicle);
          }
        });
      }

      function updateVehicleRoute(vehicle) {
        // Generate or update route if needed
        if (!vehicle.route || vehicle.route.length === 0) {
          if (vehicle.roadIndex !== vehicle.destinationRoadIndex) {
            vehicle.route = findRoute(
              vehicle.roadIndex,
              vehicle.destinationRoadIndex
            );
            vehicle.routeIndex = 0;
          }
        }

        // Check if vehicle has reached end of current road
        if (
          vehicle.pos >= 0.95 &&
          vehicle.route &&
          vehicle.routeIndex < vehicle.route.length - 1
        ) {
          // Time to transition to next road
          vehicle.routeIndex++;
          var nextRoadIndex = vehicle.route[vehicle.routeIndex];

          if (nextRoadIndex < allRoads.length) {
            vehicle.roadIndex = nextRoadIndex;
            vehicle.path = allRoads[nextRoadIndex].geometry;
            vehicle.pos = 0.05; // Start a bit into the new road

            // Calculate turn direction for turn signals
            if (vehicle.routeIndex > 0) {
              var connections =
                roadNetwork.roadConnections.get(
                  vehicle.route[vehicle.routeIndex - 1]
                ) || [];
              var connection = connections.find(
                (c) => c.toRoadIndex === nextRoadIndex
              );
              if (connection) {
                vehicle.turningDirection = connection.turnType;
                vehicle.turnSignal =
                  connection.turnType === "left"
                    ? "left"
                    : connection.turnType === "right"
                    ? "right"
                    : null;
              }
            }
          }
        }

        // Generate new destination occasionally
        if (
          vehicle.roadIndex === vehicle.destinationRoadIndex ||
          Math.random() < 0.001
        ) {
          vehicle.destinationRoadIndex = Math.floor(
            Math.random() * allRoads.length
          );
          vehicle.route = null; // Force route recalculation
        }
      }

      function checkIntersectionStatus(vehicle) {
        var currentRoad = roadNetwork.edges.get(vehicle.roadIndex);
        if (!currentRoad) return { atIntersection: false };

        var nearIntersection = false;
        var intersectionNode = null;
        var distanceToIntersection = 1.0;

        // Check if approaching end of road (intersection)
        if (vehicle.pos > 0.8) {
          intersectionNode = currentRoad.endNode;
          nearIntersection = true;
          distanceToIntersection = 1.0 - vehicle.pos;
        } else if (vehicle.pos < 0.2) {
          intersectionNode = currentRoad.startNode;
          nearIntersection = true;
          distanceToIntersection = vehicle.pos;
        }

        var node = intersectionNode
          ? roadNetwork.nodes.get(intersectionNode)
          : null;
        var isRealIntersection = node && node.isIntersection;

        return {
          atIntersection: nearIntersection && isRealIntersection,
          intersectionNode: intersectionNode,
          node: node,
          distanceToIntersection: distanceToIntersection,
          isRealIntersection: isRealIntersection,
        };
      }

      function handleIntersectionBehavior(vehicle, intersectionStatus) {
        if (!intersectionStatus.atIntersection) return;

        // Check for traffic light at intersection
        var nearbyLight = findTrafficLightAtIntersection(
          intersectionStatus.node.position
        );

        // Intersection waiting logic
        if (nearbyLight && nearbyLight.light.state === "red") {
          vehicle.waitingAtIntersection = true;
          vehicle.intersectionWaitTime++;

          // Some vehicles (especially bikes) might ignore red lights after waiting
          if (
            vehicle.intersectionWaitTime > 30 &&
            (vehicle.type === "bike" || vehicle.type === "motorcycle") &&
            Math.random() < 0.3
          ) {
            vehicle.waitingAtIntersection = false;
            vehicle.intersectionWaitTime = 0;
          }
        } else {
          vehicle.waitingAtIntersection = false;
          vehicle.intersectionWaitTime = 0;
        }

        // Yield to other vehicles logic (simplified)
        if (intersectionStatus.distanceToIntersection < 0.05) {
          var conflictingVehicles = findConflictingVehicles(
            vehicle,
            intersectionStatus
          );
          if (conflictingVehicles.length > 0 && Math.random() < 0.7) {
            vehicle.waitingAtIntersection = true;
          }
        }
      }

      function calculateVehicleMovement(vehicle, intersectionStatus) {
        var roadCongestion = getRoadCongestionLevel(vehicle.roadIndex);
        var baseSpeed = vehicle.baseSpeed * speed;
        var speedMultiplier = 1.0;

        // Road congestion effects
        switch (roadCongestion.level) {
          case 4:
            speedMultiplier *= 0.1;
            break;
          case 3:
            speedMultiplier *= 0.3;
            break;
          case 2:
            speedMultiplier *= 0.6;
            break;
          case 1:
            speedMultiplier *= 0.8;
            break;
          default:
            speedMultiplier *= 1.2;
            break;
        }

        // Intersection behavior
        if (vehicle.waitingAtIntersection) {
          speedMultiplier *= 0.05; // Almost stopped
        } else if (
          intersectionStatus.atIntersection &&
          intersectionStatus.distanceToIntersection < 0.1
        ) {
          // Slow down when approaching intersection
          speedMultiplier *= 0.7;
        }

        // Vehicle type behavior
        if (vehicle.type === "bike" || vehicle.type === "motorcycle") {
          speedMultiplier *= 1.3;
          // Bikes can navigate through congestion better
          if (roadCongestion.level > 2) {
            speedMultiplier *= 1.5;
          }
        } else if (vehicle.type === "bus" || vehicle.type === "truck") {
          speedMultiplier *= 0.8;
        }

        // Following distance (basic collision avoidance)
        var vehicleAhead = findVehicleAhead(vehicle);
        if (vehicleAhead && vehicleAhead.distance < vehicle.followingDistance) {
          speedMultiplier *= Math.max(
            0.1,
            vehicleAhead.distance / vehicle.followingDistance
          );
        }

        // Random variation and aggressiveness
        speedMultiplier *= vehicle.aggressiveness * (0.8 + Math.random() * 0.4);

        // Limit to max speed
        var finalSpeed = Math.min(
          vehicle.maxSpeed,
          baseSpeed * speedMultiplier
        );

        return {
          speed: finalSpeed,
          speedMultiplier: speedMultiplier,
          canMove: !vehicle.waitingAtIntersection || speedMultiplier > 0.1,
        };
      }

      function updateVehiclePosition(vehicle, movementData) {
        if (!movementData.canMove) return null;

        // Update position along current road
        vehicle.pos += movementData.speed;

        // Handle road completion
        if (vehicle.pos > 1) {
          vehicle.pos = 1; // Clamp to end of road

          // If no route or at end of route, loop back
          if (
            !vehicle.route ||
            vehicle.routeIndex >= vehicle.route.length - 1
          ) {
            vehicle.pos = 0;
            // Occasionally change vehicle appearance
            if (Math.random() < 0.1) {
              updateVehicleAppearance(vehicle);
            }
          }
        }

        // Calculate new position on road
        var newPoint = getPointAlongLine(vehicle.path, vehicle.pos);
        if (!newPoint) return null;

        // Add lane offset for more realistic positioning
        var laneOffset = vehicle.lane === "left" ? -0.0001 : 0.0001;
        newPoint[1] += laneOffset;

        return newPoint;
      }

      function findVehicleAhead(vehicle) {
        var minDistance = Infinity;
        var closestVehicle = null;

        vehicles.forEach((otherVehicle) => {
          if (
            otherVehicle === vehicle ||
            otherVehicle.roadIndex !== vehicle.roadIndex
          )
            return;

          // Only consider vehicles ahead on the same road
          if (
            otherVehicle.pos > vehicle.pos &&
            otherVehicle.pos - vehicle.pos < 0.2
          ) {
            var distance = otherVehicle.pos - vehicle.pos;
            if (distance < minDistance) {
              minDistance = distance;
              closestVehicle = otherVehicle;
            }
          }
        });

        return closestVehicle
          ? { vehicle: closestVehicle, distance: minDistance }
          : null;
      }

      function findConflictingVehicles(vehicle, intersectionStatus) {
        // Simplified conflict detection - find vehicles at same intersection
        return vehicles.filter((otherVehicle) => {
          if (otherVehicle === vehicle) return false;

          var otherStatus = checkIntersectionStatus(otherVehicle);
          return (
            otherStatus.atIntersection &&
            otherStatus.intersectionNode === intersectionStatus.intersectionNode
          );
        });
      }

      function findTrafficLightAtIntersection(intersectionPosition) {
        var minDistance = Infinity;
        var closestLight = null;

        Object.values(trafficLights).forEach((light) => {
          var distance = Math.sqrt(
            Math.pow(intersectionPosition[0] - light.position[0], 2) +
              Math.pow(intersectionPosition[1] - light.position[1], 2)
          );

          if (distance < 0.003 && distance < minDistance) {
            // Within 3 meters
            minDistance = distance;
            closestLight = light;
          }
        });

        return closestLight
          ? { light: closestLight, distance: minDistance }
          : null;
      }

      function updateVehicleAppearance(vehicle) {
        var newTypes = [
          { color: "#ff6b6b", size: 4, speed: 0.015, type: "car" },
          { color: "#4ecdc4", size: 3, speed: 0.025, type: "bike" },
          { color: "#45b7d1", size: 6, speed: 0.012, type: "bus" },
          { color: "#f9ca24", size: 3, speed: 0.018, type: "auto" },
          { color: "#6c5ce7", size: 5, speed: 0.013, type: "truck" },
          { color: "#a0e7e5", size: 2, speed: 0.022, type: "scooter" },
        ];

        var newType = newTypes[Math.floor(Math.random() * newTypes.length)];
        vehicle.marker.setStyle({
          fillColor: newType.color,
          radius: newType.size,
        });

        vehicle.baseSpeed = newType.speed;
        vehicle.type = newType.type;
        vehicle.maxSpeed = newType.speed * (1.2 + Math.random() * 0.3);
      }

      function updateTurnSignal(vehicle) {
        if (!vehicle.turnSignalMarker) return;

        vehicle.turnSignalTimer++;

        // Show turn signal when turning or approaching intersection with planned turn
        var shouldShowSignal =
          vehicle.turnSignal !== null &&
          (vehicle.atIntersection ||
            (vehicle.pos > 0.7 &&
              vehicle.turningDirection &&
              vehicle.turningDirection !== "straight"));

        if (shouldShowSignal) {
          // Blinking effect - show/hide every 10 frames
          var isVisible = Math.floor(vehicle.turnSignalTimer / 10) % 2 === 0;
          var signalColor =
            vehicle.turnSignal === "left" ? "#ff8800" : "#ff8800"; // Orange for turn signals

          vehicle.turnSignalMarker.setStyle({
            opacity: isVisible ? 0.8 : 0,
            color: signalColor,
            weight: 3,
          });
        } else {
          // Hide turn signal
          vehicle.turnSignalMarker.setStyle({
            opacity: 0,
          });
          vehicle.turnSignalTimer = 0;
        }
      }

      function addLaneChangeLogic(vehicle, intersectionStatus) {
        // Enhanced lane changing logic
        var laneChangeChance = 0.02; // Base 2% chance per frame

        // Increase chance in congestion
        var roadCongestion = getRoadCongestionLevel(vehicle.roadIndex);
        if (roadCongestion.level > 2) {
          laneChangeChance *= 2;
        }

        // Bikes change lanes more frequently
        if (vehicle.type === "bike" || vehicle.type === "motorcycle") {
          laneChangeChance *= 3;
        }

        // Don't change lanes when turning or at intersection
        if (vehicle.turnSignal || intersectionStatus.atIntersection) {
          laneChangeChance = 0;
        }

        if (Math.random() < laneChangeChance) {
          vehicle.lane = vehicle.lane === "left" ? "right" : "left";

          // Brief turn signal for lane change
          if (Math.random() < 0.7) {
            // 70% use turn signal
            vehicle.turnSignal = vehicle.lane === "left" ? "right" : "left"; // Signal opposite of target lane
            setTimeout(() => {
              if (vehicle.turnSignal) {
                vehicle.turnSignal = null;
              }
            }, 2000); // Clear signal after 2 seconds
          }
        }
      }

      function calculateAISpeed(nearbyLight, congestion, vehicle) {
        var baseSpeed = vehicle.speed; // Use vehicle's actual speed
        var speedFactor = 1.0;

        // Indian traffic behavior - less strict traffic light compliance
        if (nearbyLight && nearbyLight.distance < 0.005) {
          if (nearbyLight.light.state === "red") {
            // Only 70% stop completely, others slow down but may proceed
            if (Math.random() < 0.7) {
              speedFactor = 0.2; // Slow down but not complete stop
            } else {
              speedFactor = 0.8; // Some vehicles ignore red lights
            }
          } else if (nearbyLight.light.state === "yellow") {
            // Most accelerate through yellow
            speedFactor = Math.random() < 0.8 ? 1.2 : 0.5;
          }
        }

        // Aggressive overtaking in congestion
        if (congestion > 3) {
          // Heavy congestion - some vehicles find gaps
          if (vehicle.type === "bike") {
            speedFactor *= 1.5; // Bikes weave through traffic
          } else {
            speedFactor *= 0.3;
          }
        } else if (congestion > 1) {
          speedFactor *= vehicle.type === "bike" ? 1.2 : 0.6;
        }

        // Aggressive driving factor
        speedFactor *= vehicle.aggressiveness;

        // Random speed variation (Indian driving style)
        speedFactor *= 0.7 + Math.random() * 0.8; // More variation

        return Math.max(0.001, baseSpeed * speedFactor);
      }

      function findNearestTrafficLight(position) {
        var nearest = null;
        var minDistance = Infinity;

        Object.values(trafficLights).forEach((light) => {
          var distance = Math.sqrt(
            Math.pow(position.lat - light.position[0], 2) +
              Math.pow(position.lng - light.position[1], 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearest = { light: light, distance: distance };
          }
        });

        return nearest;
      }

      function analyzeRoadCongestion(path) {
        var congestion = 0;
        var pathRadius = 0.001;

        vehicles.forEach((otherVehicle) => {
          var otherPos = otherVehicle.marker.getLatLng();
          for (var i = 0; i < path.length - 1; i++) {
            var segmentDistance = distanceToLineSegment(
              [otherPos.lat, otherPos.lng],
              path[i],
              path[i + 1]
            );
            if (segmentDistance < pathRadius) {
              congestion++;
              break;
            }
          }
        });

        return congestion;
      }

      function distanceToLineSegment(point, lineStart, lineEnd) {
        var A = point[0] - lineStart[0];
        var B = point[1] - lineStart[1];
        var C = lineEnd[0] - lineStart[0];
        var D = lineEnd[1] - lineStart[1];

        var dot = A * C + B * D;
        var lenSq = C * C + D * D;

        if (lenSq === 0) return Math.sqrt(A * A + B * B);

        var param = dot / lenSq;
        var xx, yy;

        if (param < 0) {
          xx = lineStart[0];
          yy = lineStart[1];
        } else if (param > 1) {
          xx = lineEnd[0];
          yy = lineEnd[1];
        } else {
          xx = lineStart[0] + param * C;
          yy = lineStart[1] + param * D;
        }

        var dx = point[0] - xx;
        var dy = point[1] - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      var updateCounter = 0;
      var lastPerformanceCheck = Date.now();
      var fps = 0;
      var performanceWarnings = 0;
      var maxVehicles = 2000; // Increased limit for realistic traffic density
      var predictionCount = 0;
      var lastAIConfidence = 0.75; // Start with higher confidence

      // Main simulation update with Neural Network
      async function updateSimulation() {
        if (!isPlaying) return;

        var now = Date.now();
        updateCounter++;

        // Synchronized Traffic Light Management (every frame)
        synchronizeTrafficLights();

        // AI Vehicle Agent Updates (every frame but optimized)
        updateVehicleAgents();

        // Update road congestion colors every 20 frames (for performance)
        if (updateCounter % 20 === 0) {
          updateRoadCongestion();
        }

        // Performance monitoring and auto-optimization
        if (updateCounter % 50 === 0) {
          // Every 50 frames
          var elapsed = now - lastPerformanceCheck;
          fps = Math.round(50000 / elapsed);
          lastPerformanceCheck = now;

          // Auto-reduce complexity if performance is poor
          if (fps < 5 && vehicles.length > 100) {
            performanceWarnings++;
            if (performanceWarnings > 3) {
              var removeCount = Math.floor(vehicles.length * 0.3); // Remove 30%
              for (var r = 0; r < removeCount; r++) {
                var vehicle = vehicles.pop();
                if (vehicle && vehicle.marker) {
                  vehiclesLayer.removeLayer(vehicle.marker);
                  if (vehicle.turnSignalMarker) {
                    vehiclesLayer.removeLayer(vehicle.turnSignalMarker);
                  }
                }
              }
              maxVehicles = vehicles.length;
              updateLog(
                `<div class="error">‚ö†Ô∏è Auto-reduced vehicles to ${vehicles.length} for performance</div>`
              );
              performanceWarnings = 0;
            }
          } else if (fps > 15) {
            performanceWarnings = Math.max(0, performanceWarnings - 1);
          }

          // Collect data for neural network training
          if (!isTraining && updateCounter % 100 === 0) {
            // More frequent data collection
            collectTrafficData();
          }
        }

        // Neural network optimization every 200 frames (~20 seconds at 10fps)
        if (updateCounter % 200 === 0 && neuralNetwork && !isTraining) {
          var avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / (Object.keys(trafficLights).length || 1);

          var prediction = await predictOptimalTiming(
            avgDensity,
            2,
            30,
            new Date().getHours(),
            1.0,
            vehicles.length
          );

          // Track AI predictions and confidence
          predictionCount++;
          if (prediction.aiConfidence !== undefined) {
            lastAIConfidence = prediction.aiConfidence;
          }

          // Apply neural network recommendations to sync timing
          if (prediction.flow > 0.7) {
            globalPhaseOffset += prediction.sync;
          }

          // Update AI confidence display
          if (updateCounter % 100 === 0) {
            document.getElementById("confidence-value").textContent = `${(
              lastAIConfidence * 100
            ).toFixed(1)}%`;
            document.getElementById("prediction-count").textContent =
              predictionCount;

            // Update model type based on what's actually being used
            var modelType = window.transformersLoaded
              ? "Hugging Face + TensorFlow"
              : "TensorFlow (Fallback)";
            document.getElementById("model-type").textContent = modelType;
          }
        }

        // Status update every 100 frames
        if (updateCounter % 100 === 0) {
          var avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / (Object.keys(trafficLights).length || 1);

          // Calculate congestion statistics
          var congestionStats = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
          var totalRoads = allRoads.length;

          Object.values(roadCongestionLevels).forEach((road) => {
            congestionStats[road.level]++;
          });

          var freeRoads = congestionStats[0];
          var congestedRoads = congestionStats[3] + congestionStats[4];

          updateLog(
            `üö¶ Traffic: ${avgDensity.toFixed(1)} density, ${
              vehicles.length
            } vehicles | Roads: ${freeRoads} green, ${
              congestionStats[1]
            } yellow, ${
              congestionStats[2]
            } orange, ${congestedRoads} red | ${fps} fps`
          );

          // Update AI display every 100 frames
          updateAIDisplay();
        }
      }

      // Helper functions
      function getPointAlongLine(path, fraction) {
        if (!path || path.length < 2) return null;
        fraction = Math.max(0, Math.min(1, fraction));
        if (fraction === 0) return path[0];
        if (fraction === 1) return path[path.length - 1];

        var totalLength = calculatePathLength(path);
        var targetLength = totalLength * fraction;
        var cumulativeLength = 0;

        for (var i = 1; i < path.length; i++) {
          var segmentLength = dist(path[i - 1], path[i]);
          if (cumulativeLength + segmentLength >= targetLength) {
            var ratio = (targetLength - cumulativeLength) / segmentLength;
            return [
              path[i - 1][0] + ratio * (path[i][0] - path[i - 1][0]),
              path[i - 1][1] + ratio * (path[i][1] - path[i - 1][1]),
            ];
          }
          cumulativeLength += segmentLength;
        }
        return path[path.length - 1];
      }

      function calculatePathLength(path) {
        var length = 0;
        for (var i = 1; i < path.length; i++) {
          length += dist(path[i - 1], path[i]);
        }
        return length;
      }

      function dist(p1, p2) {
        return Math.sqrt(
          Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2)
        );
      }

      function updateLog(message) {
        var logElement = document.getElementById("log");
        var timestamp = new Date().toLocaleTimeString();

        // If message contains HTML, use innerHTML, otherwise use textContent
        if (message.includes("<div")) {
          logElement.innerHTML = `[${timestamp}] ${message}`;
        } else {
          logElement.innerHTML =
            `<div>[${timestamp}] ${message}</div>` + logElement.innerHTML;

          // Keep only last 10 log entries for performance
          var entries = logElement.children;
          while (entries.length > 10) {
            logElement.removeChild(entries[entries.length - 1]);
          }
        }

        // Auto-scroll to top
        logElement.scrollTop = 0;
      }

      // Event listeners
      document.getElementById("speed").addEventListener("input", function (e) {
        speed = parseFloat(e.target.value);
      });

      document
        .getElementById("geojsonInput")
        .addEventListener("change", function (e) {
          var file = e.target.files[0];
          if (file) {
            loadGeoJSON(file);
          }
        });

      document.getElementById("play").addEventListener("click", function () {
        startSimulation();
      });

      function startSimulation() {
        if (!isPlaying) {
          isPlaying = true;
          simulationInterval = setInterval(updateSimulation, 100); // Faster updates for realistic traffic (100ms)
          updateLog("‚ñ∂Ô∏è Realistic traffic simulation started");

          // Immediately update AI display when simulation starts
          updateAIDisplay();
        }
      }

      // WebGL Context Recovery
      function handleWebGLContextLoss() {
        updateLog(
          '<div class="error">‚ö†Ô∏è WebGL context lost - reducing simulation complexity</div>'
        );

        // Drastically reduce vehicle count
        if (vehicles.length > 200) {
          var keepVehicles = vehicles.slice(0, 200);
          vehicles.slice(200).forEach(function (vehicle) {
            vehiclesLayer.removeLayer(vehicle.marker);
            if (vehicle.turnSignalMarker) {
              vehiclesLayer.removeLayer(vehicle.turnSignalMarker);
            }
          });
          vehicles = keepVehicles;
          updateLog(`Reduced vehicles to ${vehicles.length} for stability`);
        }

        // Slow down the simulation even more
        if (simulationInterval) {
          clearInterval(simulationInterval);
          simulationInterval = setInterval(updateSimulation, 500); // Very slow
        }
      }

      // Monitor for WebGL errors
      window.addEventListener("error", function (e) {
        if (e.message && e.message.includes("WebGL")) {
          handleWebGLContextLoss();
        }
      });

      document.getElementById("pause").addEventListener("click", function () {
        isPlaying = false;
        clearInterval(simulationInterval);
      });

      document.getElementById("reset").addEventListener("click", function () {
        if (simulationInterval) clearInterval(simulationInterval);
        isPlaying = false;
        vehicles.forEach((v) => (v.pos = Math.random()));
        globalPhaseOffset = 0;
        updateLog("Simulation reset");
      });

      document
        .getElementById("reduceVehicles")
        .addEventListener("click", function () {
          if (vehicles.length > 50) {
            var removeCount = Math.floor(vehicles.length * 0.5); // Remove 50%
            for (var r = 0; r < removeCount; r++) {
              var vehicle = vehicles.pop();
              if (vehicle && vehicle.marker) {
                vehiclesLayer.removeLayer(vehicle.marker);
                if (vehicle.turnSignalMarker) {
                  vehiclesLayer.removeLayer(vehicle.turnSignalMarker);
                }
              }
            }
            maxVehicles = vehicles.length;
            updateLog(`üöó Manually reduced vehicles to ${vehicles.length}`);
          }
        });

      document
        .getElementById("collectData")
        .addEventListener("click", function () {
          updateLog("üìä Fast data collection started...");

          // Collect 20 samples quickly
          for (var i = 0; i < 20; i++) {
            setTimeout(function () {
              collectTrafficData();
            }, i * 100); // Collect every 100ms
          }

          setTimeout(function () {
            updateLog(
              `‚úÖ Fast collection complete. Total samples: ${trafficData.length}`
            );
          }, 2100);
        });

      document.getElementById("trainNN").addEventListener("click", function () {
        trainNeuralNetwork();
      });

      // Initialize Neural Network on page load
      window.addEventListener("load", function () {
        initNeuralNetwork();

        // Initialize AI confidence display immediately
        setTimeout(function () {
          updateAIDisplay();
        }, 1000);

        // Set up periodic AI display updates (every 5 seconds)
        setInterval(function () {
          updateAIDisplay();
        }, 5000);
      });

      // Function to update AI display elements
      function updateAIDisplay() {
        // Set initial values if elements exist
        if (document.getElementById("confidence-value")) {
          document.getElementById("confidence-value").textContent = `${(
            lastAIConfidence * 100
          ).toFixed(1)}%`;
        }
        if (document.getElementById("prediction-count")) {
          document.getElementById("prediction-count").textContent =
            predictionCount;
        }
        if (document.getElementById("model-type")) {
          var modelType = window.transformersLoaded
            ? "Hugging Face + TensorFlow"
            : "TensorFlow (Fallback)";
          document.getElementById("model-type").textContent = modelType;
        }
      }
    </script>
  </body>
</html>
