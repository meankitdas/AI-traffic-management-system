<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Simulation - Bhubaneswar</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
        #map { height: 600px; width: 100%; }
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { text-align: center; }
        #controls { text-align: center; margin: 10px; }
    </style>
</head>
<body>
    <h1>Traffic Simulation System for Bhubaneswar</h1>
    <div id="map"></div>
    <div id="controls">
        <input type="file" id="geojsonInput" accept=".geojson"><label>Upload GeoJSON File</label><br>
        <label>Simulation Speed: <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1"></label>
        <button id="play">Play</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
    </div>
    <div id="log">Simulation Log:</div>
    <script>
        var map = L.map('map').setView([20.272, 85.824], 13); // Bhubaneswar center
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        var roadsLayer = L.layerGroup().addTo(map);
        var intersectionsLayer = L.layerGroup().addTo(map);
        var vehiclesLayer = L.layerGroup().addTo(map);

        var allRoads = [];
        var allIntersections = [];
        var trafficLights = {};
        var vehicles = [];
        var simulationInterval;
        var isPlaying = false;
        var speed = 1;

        function loadGeoJSON(urlOrFile) {
            roadsLayer.clearLayers();
            intersectionsLayer.clearLayers();
            vehiclesLayer.clearLayers();
            allRoads = [];
            allIntersections = [];
            trafficLights = {};
            vehicles = [];

            if (urlOrFile instanceof File) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    processGeoJSON(JSON.parse(e.target.result));
                };
                reader.readAsText(urlOrFile);
            } else {
                fetch(urlOrFile)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => processGeoJSON(data))
                    .catch(error => {
                        console.error('Error loading GeoJSON:', error);
                        updateLog('Error loading GeoJSON file. Make sure bhubaneswar_traffic_flow.geojson is in the same directory.');
                    });
            }
        }

        function processGeoJSON(data) {
            var roadCount = 0;
            var trafficLightCount = 0;
            
            // Filter and process features
            data.features.forEach(feature => {
                if (feature.geometry.type === 'LineString' && feature.properties.highway && feature.properties.road_id) {
                    // Road
                    var coords = feature.geometry.coordinates.map(c => [c[1], c[0]]);
                    var road = L.polyline(coords, { color: 'gray', weight: 3 });
                    roadsLayer.addLayer(road);
                    allRoads.push({
                        geometry: coords,
                        properties: feature.properties,
                        layer: road
                    });
                    roadCount++;

                    // Add vehicles with car icons (only on some roads to avoid overload)
                    var vehicleCount = feature.properties.vehicle_count || 0;
                    if (Math.random() < 0.1 && vehicleCount > 0) { // Only 10% of roads get vehicles
                        var point = getPointAlongLine(coords, Math.random());
                        if (point) {
                            var carIcon = L.divIcon({
                                html: 'ðŸš—',
                                className: 'car-icon',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            });
                            var marker = L.marker(point, { icon: carIcon });
                            vehiclesLayer.addLayer(marker);
                            vehicles.push({
                                marker: marker,
                                path: coords,
                                pos: Math.random(),
                                speed: 0.002 // fraction per second
                            });
                        }
                    }
                    
                    // Add traffic lights at major intersections (simplified approach)
                    if (coords.length > 2 && Math.random() < 0.3) { // 30% chance for major roads
                        var midPoint = coords[Math.floor(coords.length / 2)];
                        var trafficLightIcon = L.divIcon({
                            html: 'ðŸš¥',
                            className: 'traffic-light-icon',
                            iconSize: [25, 25],
                            iconAnchor: [12, 12]
                        });
                        var light = L.marker(midPoint, { icon: trafficLightIcon });
                        intersectionsLayer.addLayer(light);
                        trafficLights[midPoint.join(',')] = {
                            marker: light,
                            state: 'green',
                            timer: 30 + Math.random() * 20, // Randomize initial timing
                            position: midPoint
                        };
                        trafficLightCount++;
                    }
                }
            });

            updateLog(`Loaded ${roadCount} roads, ${trafficLightCount} traffic lights, ${vehicles.length} vehicles`);
        }

        // Load default GeoJSON
        loadGeoJSON('bhubaneswar_traffic_flow.geojson');

        // AI Traffic Management System
        var trafficDensity = {};
        var congestionThreshold = 3;
        
        // AI Traffic Light Controller
        function updateTrafficLights() {
            Object.entries(trafficLights).forEach(([key, light]) => {
                var density = calculateTrafficDensity(light.position);
                var adaptiveTimer = getAdaptiveTimer(light.state, density);
                
                light.timer -= 1 * speed;
                if (light.timer <= 0) {
                    var newIcon;
                    if (light.state === 'green') {
                        light.state = 'yellow';
                        newIcon = L.divIcon({
                            html: 'ðŸŸ¡',
                            className: 'traffic-light-icon',
                            iconSize: [25, 25],
                            iconAnchor: [12, 12]
                        });
                        light.timer = 3; // Shorter yellow for efficiency
                    } else if (light.state === 'yellow') {
                        light.state = 'red';
                        newIcon = L.divIcon({
                            html: 'ðŸ”´',
                            className: 'traffic-light-icon',
                            iconSize: [25, 25],
                            iconAnchor: [12, 12]
                        });
                        light.timer = adaptiveTimer.red;
                    } else {
                        light.state = 'green';
                        newIcon = L.divIcon({
                            html: 'ðŸŸ¢',
                            className: 'traffic-light-icon',
                            iconSize: [25, 25],
                            iconAnchor: [12, 12]
                        });
                        light.timer = adaptiveTimer.green;
                    }
                    light.marker.setIcon(newIcon);
                }
            });
        }
        
        // Calculate traffic density around intersection
        function calculateTrafficDensity(position) {
            var density = 0;
            var radius = 0.01; // Search radius around intersection
            
            vehicles.forEach(vehicle => {
                var vehiclePos = vehicle.marker.getLatLng();
                var distance = Math.sqrt(
                    Math.pow(position[0] - vehiclePos.lat, 2) + 
                    Math.pow(position[1] - vehiclePos.lng, 2)
                );
                if (distance < radius) {
                    density++;
                }
            });
            return density;
        }
        
        // Adaptive timer based on traffic density
        function getAdaptiveTimer(state, density) {
            if (density > congestionThreshold) {
                // High traffic: longer green, shorter red
                return { green: 45 + density * 3, red: 20 };
            } else if (density > 1) {
                // Medium traffic: moderate timing
                return { green: 35, red: 30 };
            } else {
                // Low traffic: shorter green, longer red to save time
                return { green: 20, red: 40 };
            }
        }
        
        // AI Vehicle Agent System
        function updateVehicleAgents() {
            vehicles.forEach(vehicle => {
                // AI decision making for each vehicle
                var currentPos = vehicle.marker.getLatLng();
                var nearbyLight = findNearestTrafficLight(currentPos);
                var roadCongestion = analyzeRoadCongestion(vehicle.path);
                
                // Adjust speed based on conditions
                var baseSpeed = 0.002;
                var aiSpeed = calculateAISpeed(nearbyLight, roadCongestion, vehicle);
                
                // Update position with AI speed
                vehicle.pos += aiSpeed * speed;
                if (vehicle.pos > 1) {
                    // AI route selection: choose less congested path
                    vehicle.path = selectOptimalRoute(vehicle.path);
                    vehicle.pos = 0;
                }
                
                var newPoint = getPointAlongLine(vehicle.path, vehicle.pos);
                if (newPoint) {
                    vehicle.marker.setLatLng(newPoint);
                }
            });
        }
        
        // AI Speed Calculation
        function calculateAISpeed(nearbyLight, congestion, vehicle) {
            var baseSpeed = 0.002;
            var speedFactor = 1.0;
            
            // Traffic light awareness
            if (nearbyLight && nearbyLight.distance < 0.005) { // Close to traffic light
                if (nearbyLight.light.state === 'red') {
                    speedFactor = 0.1; // Almost stop at red light
            }
        });

        document.getElementById('pause').addEventListener('click', function() {
            isPlaying = false;
            clearInterval(simulationInterval);
        });

        document.getElementById('reset').addEventListener('click', function() {
            if (simulationInterval) clearInterval(simulationInterval);
            isPlaying = false;
            // Reset vehicles and lights
            vehicles.forEach(v => v.pos = Math.random());
            Object.values(trafficLights).forEach(l => {
                l.state = 'green';
                var greenIcon = L.divIcon({
                    html: 'ðŸŸ¢',
                    className: 'traffic-light-icon',
                    iconSize: [25, 25],
                    iconAnchor: [12, 12]
                });
                l.marker.setIcon(greenIcon);
                l.timer = 30;
            });
            updateLog('Simulation reset');
        });
    </script>
</body>
</html>
