<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Simulation - Bhubaneswar</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- Hugging Face Transformers.js for pre-trained models -->
    <script type="module">
      import {
        pipeline,
        env,
      } from "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.6.0";

      // Configure for browser usage
      env.allowRemoteModels = true;
      env.allowLocalModels = false;

      // Make available globally
      window.transformers = { pipeline, env };
      window.transformersLoaded = false;

      // Initialize the models when page loads
      window.addEventListener("DOMContentLoaded", async () => {
        try {
          // Load a lightweight regression model for traffic prediction
          window.trafficPredictor = await pipeline(
            "feature-extraction",
            "Xenova/all-MiniLM-L6-v2"
          );
          window.transformersLoaded = true;
          console.log("ü§ó Hugging Face models loaded successfully!");

          // Update status
          if (document.getElementById("neural-status")) {
            document.getElementById("neural-status").textContent =
              "AI Status: Hugging Face Pre-trained Model Ready ü§ó";
          }
        } catch (error) {
          console.error("Failed to load Hugging Face models:", error);
          window.transformersLoaded = false;
        }
      });
    </script>
    <style>
      #map {
        height: 600px;
        width: 100%;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      h1 {
        text-align: center;
      }
      #controls {
        text-align: center;
        margin: 10px;
      }
      #neural-status {
        background: #f0f0f0;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
      }
      #log {
        background: #f9f9f9;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        max-height: 150px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
        border: 1px solid #ddd;
      }
      .vehicle-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .traffic-light-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .intersection-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .loading {
        text-align: center;
        padding: 20px;
        background: #e8f4fd;
        border-radius: 5px;
        margin: 10px;
      }
      .error {
        background: #ffe6e6;
        border: 1px solid #ff9999;
        color: #cc0000;
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
      .success {
        background: #e6ffe6;
        border: 1px solid #99ff99;
        color: #006600;
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <h1>AI Traffic Simulation System for Bhubaneswar</h1>
    <div id="map"></div>
    <div id="controls">
      <input type="file" id="geojsonInput" accept=".geojson" /><label
        >Upload GeoJSON File</label
      ><br />
      <label
        >Simulation Speed:
        <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1"
      /></label>
      <button id="play">Play</button>
      <button id="pause">Pause</button>
      <button id="reset">Reset</button>
      <button id="reduceVehicles">Reduce Vehicles</button>
      <button id="collectData">Collect Data</button>
      <button id="trainNN">Train Neural Network</button>
      <button id="toggleRealistic">üöó Enhanced AI Movement</button>
    </div>
    <div id="neural-status">AI Status: Initializing AI Models...</div>
    <div
      id="ai-confidence"
      style="
        background: #e8f5e8;
        padding: 8px;
        margin: 10px;
        border-radius: 5px;
        font-size: 14px;
      "
    >
      AI Confidence: <span id="confidence-value">Loading...</span> | Model:
      <span id="model-type">Hugging Face + TensorFlow</span> | Predictions:
      <span id="prediction-count">0</span>
    </div>
    <div
      id="traffic-legend"
      style="
        background: #f0f8ff;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        font-size: 12px;
      "
    >
      <strong>üö¶ Traffic Congestion Legend:</strong><br />
      <span style="color: #00ff00; font-weight: bold">‚óè Green</span> - Free Flow
      (Fast) | <span style="color: #ffff00; font-weight: bold">‚óè Yellow</span> -
      Light Traffic |
      <span style="color: #ffa500; font-weight: bold">‚óè Orange</span> - Moderate
      | <span style="color: #ff0000; font-weight: bold">‚óè Red</span> - Heavy
      Traffic |
      <span style="color: #8b0000; font-weight: bold">‚óè Dark Red</span> - Severe
      Congestion (Stopped)
    </div>
    <div
      id="vehicle-features"
      style="
        background: #f8f9fa;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        font-size: 12px;
        border-left: 4px solid #007bff;
      "
    >
      <strong>üöó Enhanced Vehicle Features:</strong><br />
      <span style="color: #28a745">‚úì AI-Powered Pathfinding</span> - Vehicles
      find optimal routes using A* algorithm<br />
      <span style="color: #28a745">‚úì Destination-Based Movement</span> - Each
      vehicle has specific goals and stops<br />
      <span style="color: #28a745">‚úì Realistic Traffic Behavior</span> - Lane
      changing, patience, driving styles<br />
      <span style="color: #28a745">‚úì Hugging Face AI Integration</span> - Smart
      routing decisions based on traffic conditions<br />
      <span style="color: #28a745">‚úì Vehicle Type Behavior</span> - Bikes weave
      through traffic, buses are slower<br />
      <span style="color: #6c757d">üìä Graph Data: </span
      ><span id="graph-status">Loading...</span>
    </div>
    <div id="log">Simulation Log:</div>
    <script>
      var map = L.map("map").setView([20.272, 85.824], 13); // Bhubaneswar center
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      }).addTo(map);

      var roadsLayer = L.layerGroup().addTo(map);
      var intersectionsLayer = L.layerGroup().addTo(map);
      var vehiclesLayer = L.layerGroup().addTo(map);

      var allRoads = [];
      var allIntersections = [];
      var trafficLights = {};
      var vehicles = [];
      var simulationInterval;
      var isPlaying = false;
      var speed = 1;

      // Enhanced Vehicle System with Real Navigation
      var roadGraph = {}; // Graph structure from graph.json
      var intersectionNodes = {}; // Mapping of intersections to graph nodes
      var vehicleDestinations = {}; // Track vehicle destinations and routes
      var routeCache = {}; // Cache for computed routes
      var useRealisticMovement = true; // Toggle for enhanced AI movement

      // Road congestion tracking
      var roadCongestionLevels = {}; // Store congestion level for each road
      var roadUpdateCounter = 0;

      // Neural Network for Traffic Management
      var neuralNetwork = null;
      var trafficData = [];
      var isTraining = false;

      // Initialize AI System with Hugging Face Pre-trained Models
      async function initNeuralNetwork() {
        try {
          // Wait for Hugging Face models to load
          let attempts = 0;
          while (!window.transformersLoaded && attempts < 30) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            attempts++;
          }

          if (!window.transformersLoaded) {
            throw new Error(
              "Hugging Face models failed to load within timeout"
            );
          }

          // Initialize additional specialized models for traffic analysis
          try {
            // Load a time series forecasting model for traffic prediction
            window.timeSeriesModel = await window.transformers.pipeline(
              "feature-extraction",
              "Xenova/distilbert-base-uncased"
            );

            console.log("üö¶ Traffic prediction models loaded successfully");
          } catch (modelError) {
            console.warn(
              "Advanced models not available, using fallback:",
              modelError
            );
          }

          // Enhanced TensorFlow model with more features for traffic optimization
          neuralNetwork = tf.sequential({
            layers: [
              tf.layers.dense({
                inputShape: [8], // Increased input features for better prediction
                units: 64,
                activation: "relu",
                name: "traffic_dense_1",
              }),
              tf.layers.dropout({ rate: 0.3 }),
              tf.layers.dense({
                units: 32,
                activation: "relu",
                name: "traffic_dense_2",
              }),
              tf.layers.dropout({ rate: 0.2 }),
              tf.layers.dense({
                units: 16,
                activation: "relu",
                name: "traffic_dense_3",
              }),
              tf.layers.dense({ units: 4, activation: "sigmoid" }), // Output: [green_time, sync_offset, priority, flow_rate]
            ],
          });

          neuralNetwork.compile({
            optimizer: tf.train.adam(0.001),
            loss: "meanSquaredError",
            metrics: ["mae"],
          });

          document.getElementById("neural-status").textContent =
            "AI Status: Trained!";
          console.log("üß† Advanced AI traffic system initialized successfully");
        } catch (error) {
          console.error("Failed to initialize AI system:", error);
          document.getElementById("neural-status").textContent =
            "AI Status: Error - " + error.message;

          // Fallback to basic TensorFlow model
          try {
            neuralNetwork = tf.sequential({
              layers: [
                tf.layers.dense({
                  inputShape: [6],
                  units: 16,
                  activation: "relu",
                }),
                tf.layers.dense({ units: 4, activation: "sigmoid" }),
              ],
            });
            neuralNetwork.compile({
              optimizer: tf.train.adam(0.01),
              loss: "meanSquaredError",
            });
            document.getElementById("neural-status").textContent =
              "AI Status: Fallback Model Ready";
          } catch (fallbackError) {
            console.error("Even fallback model failed:", fallbackError);
          }
        }
      }

      // Traffic Light Synchronization System
      var syncGroups = {};
      var globalPhaseOffset = 0;

      function createSyncGroups() {
        // Group nearby traffic lights for synchronization
        var lightPositions = Object.keys(trafficLights).map((key) => ({
          key: key,
          pos: trafficLights[key].position,
          light: trafficLights[key],
        }));

        var groupId = 0;
        lightPositions.forEach((light1, i) => {
          if (!light1.light.syncGroup) {
            var group = [light1];
            light1.light.syncGroup = groupId;

            // Find nearby lights within 0.01 degrees
            lightPositions.forEach((light2, j) => {
              if (i !== j && !light2.light.syncGroup) {
                var distance = Math.sqrt(
                  Math.pow(light1.pos[0] - light2.pos[0], 2) +
                    Math.pow(light1.pos[1] - light2.pos[1], 2)
                );

                if (distance < 0.01) {
                  // Within sync range
                  group.push(light2);
                  light2.light.syncGroup = groupId;
                }
              }
            });

            syncGroups[groupId] = group;
            groupId++;
          }
        });
      }

      function synchronizeTrafficLights() {
        globalPhaseOffset += 0.1 * speed;

        Object.values(syncGroups).forEach((group, groupIndex) => {
          var groupPhase = (globalPhaseOffset + groupIndex * 20) % 80; // 80 second cycle

          group.forEach((lightObj, index) => {
            var light = lightObj.light;
            var phaseDelay = index * 5; // 5 second delay between lights in group
            var lightPhase = (groupPhase + phaseDelay) % 80;

            // Update light state based on synchronized phase
            var newState;
            var newIcon;

            if (lightPhase < 30) {
              newState = "green";
              newIcon = L.divIcon({
                html: "üü¢",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            } else if (lightPhase < 35) {
              newState = "yellow";
              newIcon = L.divIcon({
                html: "üü°",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            } else {
              newState = "red";
              newIcon = L.divIcon({
                html: "üî¥",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            }

            if (light.state !== newState) {
              light.state = newState;
              light.marker.setIcon(newIcon);
            }
          });
        });
      }

      // Advanced AI Prediction using Hugging Face Models
      async function predictOptimalTiming(
        density,
        congestion,
        avgSpeed,
        timeOfDay,
        weatherFactor,
        historicalFlow
      ) {
        if (!neuralNetwork)
          return {
            green: 30,
            sync: 0,
            priority: 0.5,
            flow: 1.0,
            aiConfidence: 0.1,
          };

        try {
          // Enhanced prediction with Hugging Face models
          if (window.transformersLoaded && window.trafficPredictor) {
            // Create a textual representation of traffic state for the model
            const trafficContext = `Traffic density: ${density.toFixed(
              2
            )}, congestion: ${congestion.toFixed(2)}, speed: ${avgSpeed.toFixed(
              1
            )}km/h, time: ${timeOfDay}:00, weather: ${(
              weatherFactor * 100
            ).toFixed(0)}%, flow: ${historicalFlow}`;

            try {
              // Get embeddings from the pre-trained model
              const embeddings = await window.trafficPredictor(trafficContext);

              // Extract meaningful features from embeddings
              const features = embeddings.data || embeddings;
              let avgEmbedding = 0;
              for (let i = 0; i < Math.min(8, features.length); i++) {
                avgEmbedding += features[i];
              }
              avgEmbedding = avgEmbedding / Math.min(8, features.length);

              // Use embeddings to enhance traditional prediction
              const embeddingInfluence = Math.max(
                0.1,
                Math.min(2.0, Math.abs(avgEmbedding))
              );

              // Enhanced input with embeddings
              const enhancedInput = tf.tensor2d([
                [
                  density / 10,
                  congestion / 5,
                  avgSpeed / 50,
                  timeOfDay / 24,
                  weatherFactor,
                  historicalFlow / 100,
                  embeddingInfluence, // Hugging Face embedding influence
                  Math.sin((timeOfDay * Math.PI) / 12), // Time cyclical feature
                ],
              ]);

              const prediction = neuralNetwork.predict(enhancedInput);
              const result = await prediction.data();

              enhancedInput.dispose();
              prediction.dispose();

              // Enhanced results with AI insights
              return {
                green: Math.max(
                  10,
                  Math.min(90, result[0] * 80 + embeddingInfluence * 5)
                ), // 10-90 seconds with AI influence
                sync: result[1] * 15, // 0-15 second offset
                priority: Math.max(
                  0.2,
                  Math.min(0.95, result[2] + embeddingInfluence * 0.1)
                ), // AI-enhanced priority
                flow: Math.max(
                  0.3,
                  Math.min(1.0, result[3] + embeddingInfluence * 0.2)
                ), // AI-enhanced flow
                aiConfidence: embeddingInfluence, // Confidence from AI model
              };
            } catch (hfError) {
              console.warn(
                "Hugging Face prediction failed, using fallback:",
                hfError
              );
              // Fall through to traditional prediction
            }
          }

          // Traditional TensorFlow prediction (fallback)
          const input = tf.tensor2d([
            [
              density / 10,
              congestion / 5,
              avgSpeed / 50,
              timeOfDay / 24,
              weatherFactor,
              historicalFlow / 100,
              Math.sin((timeOfDay * Math.PI) / 12), // Time cyclical feature
              (density * congestion) / 50, // Interaction feature
            ],
          ]);

          const prediction = neuralNetwork.predict(input);
          const result = await prediction.data();

          input.dispose();
          prediction.dispose();

          return {
            green: Math.max(15, Math.min(60, result[0] * 60)), // 15-60 seconds
            sync: result[1] * 10, // 0-10 second offset
            priority: result[2], // 0-1 priority factor
            flow: result[3], // 0-1 flow efficiency
            aiConfidence: 0.5, // Medium confidence for fallback
          };
        } catch (error) {
          console.error("AI prediction error:", error);
          return {
            green: 30,
            sync: 0,
            priority: 0.5,
            flow: 1.0,
            aiConfidence: 0.1,
          };
        }
      }

      // Collect training data
      function collectTrafficData() {
        if (trafficData.length > 1000) trafficData.shift(); // Keep last 1000 records

        var avgDensity = 0;
        var lightCount = Object.keys(trafficLights).length;

        if (lightCount > 0) {
          avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / lightCount;
        }

        var avgCongestion = 0;
        var avgSpeed = 25; // Default speed

        if (vehicles.length > 0) {
          // Simplified congestion calculation for performance
          avgCongestion = Math.min(5, vehicles.length / 50); // Estimate based on vehicle density
          avgSpeed =
            vehicles.reduce((sum, v) => sum + v.speed * 1000, 0) /
            vehicles.length;
        }

        var timeOfDay = new Date().getHours();
        var weatherFactor = 1.0; // Could be dynamic based on weather API
        var historicalFlow = vehicles.length;

        // Calculate efficiency (lower density and congestion = higher efficiency)
        var efficiency = Math.max(0.1, 1 - avgDensity / 10 - avgCongestion / 8);

        // Enhanced features for AI model
        var timeFeature = Math.sin((timeOfDay * Math.PI) / 12);
        var interactionFeature = (avgDensity * avgCongestion) / 50;

        // More realistic target values based on current conditions
        var optimalGreen = Math.max(0.3, Math.min(0.9, 0.4 + avgDensity / 15));
        var optimalSync = Math.random() * 0.6 + 0.2; // 0.2 to 0.8
        var optimalPriority = Math.max(0.4, Math.min(0.9, efficiency + 0.1));

        // Enhanced training data with more features for Hugging Face integration
        trafficData.push({
          input: [
            avgDensity / 10,
            avgCongestion / 5,
            avgSpeed / 50,
            timeOfDay / 24,
            weatherFactor,
            historicalFlow / 100,
            timeFeature, // Time cyclical feature
            interactionFeature, // Density-congestion interaction
          ],
          output: [efficiency, optimalGreen, optimalSync, optimalPriority],
        });

        // Log data collection progress
        if (trafficData.length % 10 === 0) {
          updateLog(`üìä Collected ${trafficData.length} training samples`);
        }
      }

      // Generate training data quickly for demonstration
      function generateTrainingData() {
        updateLog("üß† Generating training data...");

        // Generate synthetic training data based on current simulation state
        for (var i = trafficData.length; i < 100; i++) {
          var syntheticDensity = Math.random() * 10;
          var syntheticCongestion = Math.random() * 5;
          var syntheticSpeed = 20 + Math.random() * 30;
          var syntheticTimeOfDay = Math.random() * 24;
          var syntheticWeather = 0.8 + Math.random() * 0.4;
          var syntheticFlow = Math.random() * 100;

          // Calculate realistic efficiency based on conditions
          var efficiency = Math.max(
            0.1,
            1 - syntheticDensity / 15 - syntheticCongestion / 10
          );
          var optimalGreen = Math.min(0.9, 0.3 + syntheticDensity / 20);
          var optimalSync = Math.random() * 0.8;
          var optimalPriority = Math.min(0.9, efficiency + 0.1);

          trafficData.push({
            input: [
              syntheticDensity / 10,
              syntheticCongestion / 5,
              syntheticSpeed / 50,
              syntheticTimeOfDay / 24,
              syntheticWeather,
              syntheticFlow / 100,
            ],
            output: [efficiency, optimalGreen, optimalSync, optimalPriority],
          });
        }

        updateLog(`‚úÖ Generated ${trafficData.length} training samples`);
      }

      // Train Neural Network
      async function trainNeuralNetwork() {
        // Prevent multiple concurrent training sessions
        if (isTraining) {
          updateLog(
            '<div class="error">‚ö†Ô∏è Training already in progress. Please wait...</div>'
          );
          return;
        }

        if (!neuralNetwork) {
          document.getElementById("neural-status").textContent =
            "Neural Network not initialized";
          return;
        }

        if (trafficData.length < 50) {
          updateLog(`üìä Current data: ${trafficData.length}/50 samples`);
          generateTrainingData(); // Generate data if we don't have enough
        }

        isTraining = true;

        // Update UI to show training in progress
        const trainButton = document.getElementById("trainNN");
        trainButton.textContent = "Training... ‚è≥";
        trainButton.disabled = true;

        document.getElementById("neural-status").textContent =
          "Training Neural Network...";
        updateLog("üß† Starting neural network training...");

        try {
          // Validate training data
          if (trafficData.length === 0) {
            throw new Error("No training data available");
          }

          const inputs = tf.tensor2d(trafficData.map((d) => d.input));
          const outputs = tf.tensor2d(trafficData.map((d) => d.output));

          updateLog(`üéØ Training with ${trafficData.length} samples...`);

          await neuralNetwork.fit(inputs, outputs, {
            epochs: 30, // Reduced epochs for faster training
            batchSize: Math.min(10, Math.floor(trafficData.length / 4)), // Dynamic batch size
            validationSplit: 0.2,
            shuffle: true, // Shuffle data for better training
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                if (epoch % 5 === 0) {
                  // Update every 5 epochs
                  const progress = Math.round((epoch / 30) * 100);
                  document.getElementById(
                    "neural-status"
                  ).textContent = `Training: ${progress}% (Epoch ${epoch}/30, Loss: ${logs.loss.toFixed(
                    4
                  )})`;
                  updateLog(
                    `üìà Training progress: ${progress}% - Loss: ${logs.loss.toFixed(
                      4
                    )}`
                  );
                }
              },
              onTrainEnd: () => {
                updateLog("‚úÖ Training completed successfully!");
              },
            },
          });

          // Clean up tensors to prevent memory leaks
          inputs.dispose();
          outputs.dispose();

          document.getElementById("neural-status").textContent =
            "Neural Network: Trained Successfully ‚úÖ";
          updateLog(
            '<div class="success">üéâ Neural Network training completed! AI optimization is now active.</div>'
          );
        } catch (error) {
          console.error("Training error:", error);
          let errorMessage = error.message;

          // Provide user-friendly error messages
          if (errorMessage.includes("fit() call is ongoing")) {
            errorMessage =
              "Another training session is already running. Please wait for it to complete.";
          } else if (errorMessage.includes("tensor")) {
            errorMessage =
              "Data format error. Please try collecting new training data.";
          }

          document.getElementById("neural-status").textContent =
            "Training Failed: " + errorMessage;
          updateLog(
            `<div class="error">‚ùå Training failed: ${errorMessage}</div>`
          );
        } finally {
          isTraining = false;

          // Reset UI
          const trainButton = document.getElementById("trainNN");
          trainButton.textContent = "Train Neural Network";
          trainButton.disabled = false;

          updateLog("üîÑ Training session ended. Ready for new training.");
        }
      }

      function loadGeoJSON(urlOrFile) {
        // Clear existing data
        roadsLayer.clearLayers();
        intersectionsLayer.clearLayers();
        vehiclesLayer.clearLayers();
        allRoads = [];
        allIntersections = [];
        trafficLights = {};
        vehicles = [];
        syncGroups = {};

        // Show loading indicator
        updateLog('<div class="loading">üîÑ Loading GeoJSON data...</div>');

        if (urlOrFile instanceof File) {
          var reader = new FileReader();
          reader.onload = function (e) {
            try {
              var data = JSON.parse(e.target.result);
              processGeoJSON(data);
            } catch (error) {
              console.error("Error parsing uploaded file:", error);
              updateLog(
                '<div class="error">‚ùå Error parsing uploaded file. Please check the file format.</div>'
              );
            }
          };
          reader.onerror = function () {
            updateLog(
              '<div class="error">‚ùå Error reading uploaded file.</div>'
            );
          };
          reader.readAsText(urlOrFile);
        } else {
          fetch(urlOrFile)
            .then((response) => {
              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                );
              }
              return response.json();
            })
            .then((data) => {
              updateLog(
                '<div class="success">‚úÖ GeoJSON loaded successfully!</div>'
              );
              processGeoJSON(data);
            })
            .catch((error) => {
              console.error("Error loading GeoJSON:", error);
              updateLog(
                `<div class="error">‚ùå Error loading GeoJSON: ${error.message}</div>`
              );

              // Try to create a fallback simulation with demo data
              updateLog(
                '<div class="loading">üîÑ Creating demo traffic simulation...</div>'
              );
              createDemoSimulation();
            });
        }
      }

      function createDemoSimulation() {
        // Create a realistic demo road network for Bhubaneswar with more roads
        var demoRoads = [
          // Major arterial roads
          [
            [20.272, 85.82],
            [20.275, 85.825],
            [20.278, 85.83],
            [20.281, 85.835],
          ],
          [
            [20.27, 85.815],
            [20.272, 85.82],
            [20.274, 85.825],
            [20.276, 85.83],
          ],
          [
            [20.268, 85.822],
            [20.27, 85.827],
            [20.272, 85.832],
            [20.274, 85.837],
          ],
          [
            [20.275, 85.818],
            [20.277, 85.823],
            [20.279, 85.828],
            [20.281, 85.833],
          ],
          [
            [20.265, 85.825],
            [20.268, 85.83],
            [20.271, 85.835],
            [20.274, 85.84],
          ],

          // Cross streets for realistic grid
          [
            [20.269, 85.815],
            [20.269, 85.825],
            [20.269, 85.835],
          ],
          [
            [20.273, 85.817],
            [20.273, 85.827],
            [20.273, 85.837],
          ],
          [
            [20.277, 85.819],
            [20.277, 85.829],
            [20.277, 85.839],
          ],

          // Ring roads
          [
            [20.266, 85.816],
            [20.27, 85.82],
            [20.274, 85.824],
            [20.278, 85.828],
            [20.282, 85.832],
          ],
          [
            [20.28, 85.818],
            [20.276, 85.822],
            [20.272, 85.826],
            [20.268, 85.83],
            [20.264, 85.834],
          ],

          // Additional connecting roads
          [
            [20.271, 85.816],
            [20.275, 85.821],
            [20.279, 85.826],
          ],
          [
            [20.267, 85.823],
            [20.271, 85.828],
            [20.275, 85.833],
          ],
          [
            [20.273, 85.819],
            [20.277, 85.824],
            [20.281, 85.829],
          ],
        ];

        demoRoads.forEach((roadCoords, index) => {
          var road = L.polyline(roadCoords, { color: "#666", weight: 3 });
          roadsLayer.addLayer(road);

          // Classify roads by length and position for major junction identification
          var roadLength = calculatePathLength(roadCoords);
          var roadType, vehicleCount;

          // More selective classification - only longest roads are "primary"
          if (roadLength > 0.025) {
            roadType = "primary";
            vehicleCount = Math.floor(Math.random() * 30) + 20; // High traffic
          } else if (roadLength > 0.02) {
            roadType = "secondary";
            vehicleCount = Math.floor(Math.random() * 20) + 10; // Medium traffic
          } else if (roadLength > 0.015) {
            roadType = "tertiary";
            vehicleCount = Math.floor(Math.random() * 12) + 6; // Low traffic
          } else {
            roadType = "residential";
            vehicleCount = Math.floor(Math.random() * 8) + 2; // Very low traffic
          }

          // Mark major arterial roads (first few longest roads)
          if (index < 3 && roadLength > 0.02) {
            roadType = "trunk"; // Major arterial designation
            vehicleCount += 10; // Boost traffic for major roads
          }

          allRoads.push({
            geometry: roadCoords,
            properties: {
              road_id: `demo_${index}`,
              highway: roadType,
              vehicle_count: vehicleCount,
            },
            layer: road,
          });

          // Add vehicles to demo road
          addVehiclesToRoad(roadCoords, {
            vehicle_count: vehicleCount,
          });

          // Use intelligent traffic light placement (much fewer lights)
          addTrafficLight(roadCoords, {
            highway: roadType,
            vehicle_count: vehicleCount,
          });
        });

        createSyncGroups();
        var lightCount = Object.keys(trafficLights).length;
        var lightDensity = ((lightCount / allRoads.length) * 100).toFixed(1);

        updateLog(
          `<div class="success">‚úÖ Demo simulation created: ${allRoads.length} roads, ${vehicles.length} vehicles, ${lightCount} traffic lights (${lightDensity}% road coverage - major junctions only)</div>`
        );
        setTimeout(startSimulation, 1000); // Auto-start after 1 second
      }

      function processGeoJSON(data) {
        var roadCount = 0;
        var trafficLightCount = 0;
        var pointCount = 0;

        // Check what type of data we have
        var hasLineStrings = data.features.some(
          (f) => f.geometry.type === "LineString"
        );
        var hasPoints = data.features.some((f) => f.geometry.type === "Point");

        updateLog(
          `Processing ${data.features.length} features. LineStrings: ${hasLineStrings}, Points: ${hasPoints}`
        );

        if (!hasLineStrings && hasPoints) {
          // If we only have points, create synthetic roads between nearby points
          updateLog(
            "No LineString roads found. Creating synthetic road network from points..."
          );
          createSyntheticRoads(data.features);
          setTimeout(startSimulation, 1000); // Auto-start after 1 second
          return;
        }

        data.features.forEach((feature) => {
          if (
            feature.geometry.type === "LineString" &&
            feature.properties.highway &&
            feature.properties.road_id
          ) {
            var coords = feature.geometry.coordinates.map((c) => [c[1], c[0]]);
            var road = L.polyline(coords, { color: "gray", weight: 3 });
            roadsLayer.addLayer(road);
            allRoads.push({
              geometry: coords,
              properties: feature.properties,
              layer: road,
            });
            roadCount++;

            // Add vehicles to roads
            addVehiclesToRoad(coords, feature.properties);

            // Add traffic lights (VERY restrictive - major junctions only)
            if (coords.length > 3 && calculatePathLength(coords) > 0.015) {
              // Only longer roads with multiple points
              var lightCountBefore = Object.keys(trafficLights).length;
              addTrafficLight(coords, feature.properties);
              var lightCountAfter = Object.keys(trafficLights).length;
              if (lightCountAfter > lightCountBefore) {
                trafficLightCount++;
              }
            }
          } else if (feature.geometry.type === "Point") {
            // Process traffic signals and intersections from point data
            processPointFeature(feature);
            pointCount++;
          }
        });

        // Create synchronization groups after loading all lights
        createSyncGroups();
        updateLog(
          `<div class="success">‚úÖ Loaded ${roadCount} roads, ${pointCount} points, ${trafficLightCount} traffic lights (${
            Object.keys(syncGroups).length
          } sync groups), ${vehicles.length} vehicles</div>`
        );
        if (vehicles.length > 0) {
          setTimeout(startSimulation, 1000); // Auto-start if we have vehicles
        }
      }

      function createSyntheticRoads(pointFeatures) {
        var points = pointFeatures
          .filter(
            (f) =>
              f.geometry.type === "Point" && f.properties.road_id !== undefined
          )
          .map((f) => ({
            coords: [f.geometry.coordinates[1], f.geometry.coordinates[0]], // lat, lng
            properties: f.properties,
          }))
          .slice(0, 50); // Limit to 50 points for performance

        // Create roads between nearby points
        for (var i = 0; i < points.length; i++) {
          for (var j = i + 1; j < points.length; j++) {
            var distance = calculateDistance(
              points[i].coords,
              points[j].coords
            );
            if (distance < 0.02 && Math.random() < 0.3) {
              // 2km max distance, 30% chance
              var roadCoords = [points[i].coords, points[j].coords];
              var road = L.polyline(roadCoords, {
                color: "#666",
                weight: 2,
                opacity: 0.7,
              });
              roadsLayer.addLayer(road);
              allRoads.push({
                geometry: roadCoords,
                properties: {
                  road_id: `synthetic_${i}_${j}`,
                  highway: "synthetic",
                  vehicle_count: Math.floor(Math.random() * 50) + 10,
                },
                layer: road,
              });

              // Add vehicles to synthetic road
              addVehiclesToRoad(roadCoords, {
                vehicle_count: Math.floor(Math.random() * 20) + 5,
              });
            }
          }
        }

        // Add traffic lights only at major intersections (much reduced)
        points.slice(0, 8).forEach((point) => {
          // VERY restrictive - only actual traffic signals and major junctions
          if (
            point.properties.highway === "traffic_signals" ||
            (point.properties.junction === "yes" &&
              point.properties.highway === "primary" &&
              Math.random() < 0.2) || // Only primary road junctions with 20% chance
            Math.random() < 0.03 // Reduced from 0.1 to 0.03 (3% chance for random)
          ) {
            addTrafficLightAtPoint(point.coords);
          }
        });

        updateLog(
          `<div class="success">‚úÖ Created ${allRoads.length} synthetic roads from ${points.length} points with ${vehicles.length} vehicles</div>`
        );
        if (vehicles.length > 0) {
          setTimeout(startSimulation, 1000); // Auto-start if we have vehicles
        }
      }

      function addVehiclesToRoad(coords, properties) {
        var vehicleCount = properties.vehicle_count || 0;

        if (Math.random() < 0.8) {
          // Increase to 80% of roads get vehicles for realistic traffic
          var roadLength = calculatePathLength(coords);
          var vehiclesPerRoad = Math.min(
            12, // Increased vehicles per road for better traffic density
            Math.max(2, Math.floor(roadLength * 100 + vehicleCount * 0.15)) // Higher density
          );

          for (var v = 0; v < vehiclesPerRoad; v++) {
            var point = getPointAlongLine(coords, Math.random());
            if (point) {
              // Optimized vehicle types with simple colored circles (no emojis)
              var vehicleTypes = [
                {
                  speed: 0.015,
                  type: "car",
                  color: "#ff6b6b",
                  size: 4,
                  shape: "circle"
                },
                {
                  speed: 0.025,
                  type: "bike",
                  color: "#4ecdc4",
                  size: 3,
                  shape: "circle"
                },
                {
                  speed: 0.012,
                  type: "bus",
                  color: "#45b7d1",
                  size: 6,
                  shape: "square"
                },
                {
                  speed: 0.018,
                  type: "auto",
                  color: "#f9ca24",
                  size: 3,
                  shape: "triangle"
                },
                {
                  speed: 0.013,
                  type: "truck",
                  color: "#6c5ce7",
                  size: 5,
                  shape: "square"
                },
                {
                  speed: 0.022,
                  type: "scooter",
                  color: "#a0e7e5",
                  size: 2,
                  shape: "circle"
                },
                {
                  speed: 0.017,
                  type: "taxi",
                  color: "#feca57",
                  size: 4,
                  shape: "diamond"
                },
                {
                  speed: 0.028,
                  type: "motorcycle",
                  color: "#ff9ff3",
                  size: 3,
                  shape: "circle"
                },
              ];

              var vehicleType = vehicleTypes[Math.floor(Math.random() * 8)];

              // Create more realistic vehicle markers with different sizes
              var vehicleIcon = L.circleMarker(point, {
                radius: vehicleType.size,
                fillColor: vehicleType.color,
                color: "#333",
                weight: 1,
                opacity: 0.9,
                fillOpacity: 0.8,
              });

              vehiclesLayer.addLayer(vehicleIcon);

              // Create realistic vehicle with destination-based behavior
              const vehicleId = `vehicle_${vehicles.length}`;
              const startPos = point;
              const destinationPos = generateRandomDestination(startPos);
              const route = findRoute(startPos, destinationPos);

              vehicles.push({
                id: vehicleId,
                marker: vehicleIcon,
                path: coords,
                pos: Math.random(),
                speed: vehicleType.speed * (0.7 + Math.random() * 0.6),
                baseSpeed: vehicleType.speed,
                type: vehicleType.type,
                aggressiveness: 0.3 + Math.random() * 0.7,
                lane: Math.random() < 0.5 ? "left" : "right",
                lastUpdate: 0,
                roadIndex: allRoads.length - 1,
                // Enhanced realistic navigation properties
                destination: destinationPos,
                route: route,
                currentRouteIndex: 0,
                currentRoadSegment: coords,
                isAtIntersection: false,
                waitingAtLight: false,
                stoppedTime: 0,
                routeProgress: 0,
                hasReachedDestination: false,
                // AI-driven behavior properties
                drivingStyle: generateDrivingStyle(vehicleType.type),
                patience: Math.random() * 100, // Patience level for traffic
                routeKnowledge: Math.random() > 0.3 ? "good" : "poor", // GPS/local knowledge
              });

              if (vehicles.length >= maxVehicles) break;
            }
          }
        }
      }

      function addTrafficLight(coords, properties) {
        // VERY RESTRICTIVE: Only major junctions and arterial roads get traffic lights
        var roadLength = calculatePathLength(coords);
        var vehicleCount = properties?.vehicle_count || 0;
        var roadType = properties?.highway || "unknown";

        // Major junction criteria - much more restrictive
        var shouldAddLight = false;

        // Only major arterial roads get consideration
        if (roadLength > 0.025) {
          // Very long roads (major arterials only) - 30% chance (reduced from 60%)
          shouldAddLight = Math.random() < 0.3;
        } else if (roadLength > 0.02) {
          // Long roads - 15% chance (reduced from 30%)
          shouldAddLight = Math.random() < 0.15;
        } else if (roadLength > 0.015) {
          // Medium roads - 8% chance (reduced from 15%)
          shouldAddLight = Math.random() < 0.08;
        } else {
          // Small roads/lanes - NO traffic lights (was 5%)
          shouldAddLight = false;
        }

        // High traffic volume override (more restrictive)
        if (vehicleCount > 15) {
          // Only very high traffic roads get priority - 40% chance (reduced from 80%)
          shouldAddLight = Math.random() < 0.4;
        } else if (vehicleCount > 10) {
          // High traffic - 20% chance
          shouldAddLight = Math.random() < 0.2;
        }

        // Road type priority (only major road types)
        if (roadType === "primary" || roadType === "trunk") {
          shouldAddLight = shouldAddLight && Math.random() < 0.5; // Further reduce by 50%
        } else if (roadType === "secondary") {
          shouldAddLight = shouldAddLight && Math.random() < 0.3; // Further reduce by 70%
        } else if (roadType === "residential" || roadType === "tertiary") {
          shouldAddLight = false; // No lights on residential/small roads
        }

        if (shouldAddLight) {
          var midPoint = coords[Math.floor(coords.length / 2)];
          addTrafficLightAtPoint(midPoint);
        }
      }

      function addTrafficLightAtPoint(point) {
        var trafficLightIcon = L.divIcon({
          html: '<div style="font-size: 18px;">üö•</div>',
          className: "traffic-light-icon",
          iconSize: [25, 25],
          iconAnchor: [12, 12],
        });
        var light = L.marker(point, { icon: trafficLightIcon });
        intersectionsLayer.addLayer(light);
        trafficLights[point.join(",")] = {
          marker: light,
          state: "green",
          timer: 30 + Math.random() * 20,
          position: point,
          syncGroup: null,
        };
      }

      function processPointFeature(feature) {
        var coords = [
          feature.geometry.coordinates[1],
          feature.geometry.coordinates[0],
        ];

        if (feature.properties.highway === "traffic_signals") {
          addTrafficLightAtPoint(coords);
        } else if (feature.properties.junction === "yes") {
          // Add intersection marker
          var intersectionIcon = L.divIcon({
            html: '<div style="font-size: 16px;">‚≠ï</div>',
            className: "intersection-icon",
            iconSize: [20, 20],
            iconAnchor: [10, 10],
          });
          var marker = L.marker(coords, { icon: intersectionIcon });
          intersectionsLayer.addLayer(marker);
        }
      }

      function calculateDistance(point1, point2) {
        var R = 6371; // Earth's radius in km
        var dLat = ((point2[0] - point1[0]) * Math.PI) / 180;
        var dLng = ((point2[1] - point1[1]) * Math.PI) / 180;
        var a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((point1[0] * Math.PI) / 180) *
            Math.cos((point2[0] * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // Enhanced Traffic Data Loading System
      async function loadTrafficData() {
        updateLog(
          '<div class="loading">üîÑ Loading comprehensive traffic data...</div>'
        );

        try {
          // Load graph data for pathfinding
          const graphResponse = await fetch("graph.json");
          if (graphResponse.ok) {
            roadGraph = await graphResponse.json();
            updateLog("‚úÖ Road graph loaded for intelligent pathfinding");
            document.getElementById("graph-status").textContent =
              "Loaded successfully ‚úÖ";
            document.getElementById("graph-status").style.color = "#28a745";
            preprocessGraph();
          } else {
            updateLog(
              "‚ö†Ô∏è Graph data not available, using simplified navigation"
            );
            document.getElementById("graph-status").textContent =
              "Not available ‚ö†Ô∏è";
            document.getElementById("graph-status").style.color = "#ffc107";
          }
        } catch (error) {
          updateLog("‚ö†Ô∏è Graph loading failed, using basic navigation");
          document.getElementById("graph-status").textContent =
            "Failed to load ‚ùå";
          document.getElementById("graph-status").style.color = "#dc3545";
        }

        // Load GeoJSON data
        loadGeoJSON("bhubaneswar_traffic_flow.geojson");
      }

      // Preprocess graph for efficient pathfinding
      function preprocessGraph() {
        // Create intersection mapping and prepare for A* pathfinding
        Object.keys(roadGraph).forEach((nodeKey) => {
          const [lng, lat] = nodeKey.slice(1, -1).split(", ").map(parseFloat);
          intersectionNodes[nodeKey] = {
            position: [lat, lng],
            connections: roadGraph[nodeKey],
            id: nodeKey,
          };
        });

        updateLog(
          `üìç Processed ${
            Object.keys(intersectionNodes).length
          } intersection nodes`
        );
      }

      // A* Pathfinding Algorithm for realistic route planning
      function findRoute(startPos, endPos) {
        const cacheKey = `${startPos[0]},${startPos[1]}-${endPos[0]},${endPos[1]}`;
        if (routeCache[cacheKey]) {
          return routeCache[cacheKey];
        }

        const startNode = findNearestNode(startPos);
        const endNode = findNearestNode(endPos);

        if (!startNode || !endNode) {
          return null;
        }

        const route = aStarPathfinding(startNode, endNode);
        routeCache[cacheKey] = route;
        return route;
      }

      // Find nearest graph node to a position
      function findNearestNode(position) {
        let nearest = null;
        let minDistance = Infinity;

        Object.values(intersectionNodes).forEach((node) => {
          const distance = calculateDistance(position, node.position);
          if (distance < minDistance) {
            minDistance = distance;
            nearest = node;
          }
        });

        return nearest;
      }

      // A* Pathfinding Implementation
      function aStarPathfinding(startNode, endNode) {
        const openSet = [startNode];
        const closedSet = new Set();
        const gScore = { [startNode.id]: 0 };
        const fScore = { [startNode.id]: heuristic(startNode, endNode) };
        const cameFrom = {};

        while (openSet.length > 0) {
          // Find node with lowest fScore
          let current = openSet.reduce((min, node) =>
            fScore[node.id] < fScore[min.id] ? node : min
          );

          if (current.id === endNode.id) {
            return reconstructPath(cameFrom, current);
          }

          openSet.splice(openSet.indexOf(current), 1);
          closedSet.add(current.id);

          // Check all neighbors
          current.connections.forEach((connection) => {
            const neighborId = `(${connection.node[0]}, ${connection.node[1]})`;
            const neighbor = intersectionNodes[neighborId];

            if (!neighbor || closedSet.has(neighborId)) return;

            const tentativeGScore = gScore[current.id] + connection.data.length;

            if (!openSet.find((n) => n.id === neighborId)) {
              openSet.push(neighbor);
            } else if (tentativeGScore >= (gScore[neighborId] || Infinity)) {
              return;
            }

            cameFrom[neighborId] = current;
            gScore[neighborId] = tentativeGScore;
            fScore[neighborId] = tentativeGScore + heuristic(neighbor, endNode);
          });
        }

        return null; // No path found
      }

      // Heuristic function for A* (Euclidean distance)
      function heuristic(nodeA, nodeB) {
        return calculateDistance(nodeA.position, nodeB.position);
      }

      // Reconstruct path from A* result
      function reconstructPath(cameFrom, current) {
        const path = [current];
        while (cameFrom[current.id]) {
          current = cameFrom[current.id];
          path.unshift(current);
        }
        return path;
      }

      // Generate random destination for realistic vehicle movement
      function generateRandomDestination(startPos) {
        // Select a random intersection as destination
        const intersectionKeys = Object.keys(intersectionNodes);
        if (intersectionKeys.length === 0) {
          // Fallback to random nearby position
          return [
            startPos[0] + (Math.random() - 0.5) * 0.02,
            startPos[1] + (Math.random() - 0.5) * 0.02,
          ];
        }

        const randomIntersection =
          intersectionKeys[Math.floor(Math.random() * intersectionKeys.length)];
        return intersectionNodes[randomIntersection].position;
      }

      // Generate driving style based on vehicle type
      function generateDrivingStyle(vehicleType) {
        const styles = {
          car: { aggression: 0.5, speedVariance: 0.3, laneChangeFreq: 0.1 },
          bike: { aggression: 0.8, speedVariance: 0.5, laneChangeFreq: 0.3 },
          motorcycle: {
            aggression: 0.9,
            speedVariance: 0.6,
            laneChangeFreq: 0.4,
          },
          bus: { aggression: 0.3, speedVariance: 0.2, laneChangeFreq: 0.05 },
          truck: { aggression: 0.2, speedVariance: 0.2, laneChangeFreq: 0.03 },
          auto: { aggression: 0.7, speedVariance: 0.4, laneChangeFreq: 0.2 },
          taxi: { aggression: 0.6, speedVariance: 0.4, laneChangeFreq: 0.15 },
          scooter: {
            aggression: 0.7,
            speedVariance: 0.4,
            laneChangeFreq: 0.25,
          },
        };

        return styles[vehicleType] || styles.car;
      }

      // Enhanced AI decision-making using Hugging Face models
      async function makeAIRoutingDecision(
        vehicle,
        currentPos,
        trafficConditions
      ) {
        if (!window.transformersLoaded || !window.trafficPredictor) {
          return makeBasicRoutingDecision(vehicle, trafficConditions);
        }

        try {
          // Create context for AI model
          const context = `Vehicle type: ${
            vehicle.type
          }, patience: ${vehicle.patience.toFixed(0)}, 
                          congestion: ${
                            trafficConditions.congestion
                          }, traffic light: ${trafficConditions.lightState}, 
                          route knowledge: ${
                            vehicle.routeKnowledge
                          }, driving style: aggressive ${(
            vehicle.drivingStyle.aggression * 100
          ).toFixed(0)}%`;

          // Get AI embeddings for decision making
          const embeddings = await window.trafficPredictor(context);
          const features = embeddings.data || embeddings;

          // Use AI insights for routing decisions
          let aiInfluence = 0;
          for (let i = 0; i < Math.min(4, features.length); i++) {
            aiInfluence += features[i];
          }
          aiInfluence = aiInfluence / Math.min(4, features.length);

          // AI-influenced decision making
          const shouldChangeRoute =
            Math.abs(aiInfluence) > 0.3 && trafficConditions.congestion > 2;
          const shouldSpeed = aiInfluence > 0.2 && vehicle.patience > 70;
          const shouldWait = aiInfluence < -0.2 || vehicle.patience < 30;

          return {
            changeRoute: shouldChangeRoute,
            speedUp: shouldSpeed,
            wait: shouldWait,
            aiConfidence: Math.abs(aiInfluence),
            decision:
              aiInfluence > 0.3
                ? "aggressive"
                : aiInfluence < -0.3
                ? "cautious"
                : "normal",
          };
        } catch (error) {
          console.warn("AI routing decision failed:", error);
          return makeBasicRoutingDecision(vehicle, trafficConditions);
        }
      }

      // Fallback routing decision without AI
      function makeBasicRoutingDecision(vehicle, trafficConditions) {
        const shouldChangeRoute =
          trafficConditions.congestion > 3 && Math.random() < 0.2;
        const shouldSpeed = vehicle.patience > 60 && Math.random() < 0.3;
        const shouldWait =
          trafficConditions.lightState === "red" && Math.random() < 0.7;

        return {
          changeRoute: shouldChangeRoute,
          speedUp: shouldSpeed,
          wait: shouldWait,
          aiConfidence: 0.3,
          decision: vehicle.aggressiveness > 0.6 ? "aggressive" : "normal",
        };
      }

      // Load both GeoJSON and graph data
      loadTrafficData();

      // Calculate traffic density around intersection
      function calculateTrafficDensity(position) {
        var density = 0;
        var radius = 0.01;

        vehicles.forEach((vehicle) => {
          var vehiclePos = vehicle.marker.getLatLng();
          var distance = Math.sqrt(
            Math.pow(position[0] - vehiclePos.lat, 2) +
              Math.pow(position[1] - vehiclePos.lng, 2)
          );
          if (distance < radius) {
            density++;
          }
        });
        return density;
      }

      // Calculate road congestion levels and update colors
      function updateRoadCongestion() {
        roadUpdateCounter++;

        allRoads.forEach((road, roadIndex) => {
          var roadId = `road_${roadIndex}`;
          var vehiclesOnRoad = 0;
          var totalSpeed = 0;
          var stoppedVehicles = 0;

          // Count vehicles on this specific road
          vehicles.forEach((vehicle) => {
            if (vehicle.roadIndex === roadIndex) {
              vehiclesOnRoad++;
              totalSpeed += vehicle.speed;

              // Check if vehicle is nearly stopped (very slow)
              if (vehicle.speed < 0.002) {
                stoppedVehicles++;
              }
            }
          });

          // Calculate congestion metrics
          var roadLength = calculatePathLength(road.geometry);
          var vehicleDensity = vehiclesOnRoad / Math.max(0.1, roadLength * 100); // vehicles per unit length
          var avgSpeed =
            vehiclesOnRoad > 0 ? totalSpeed / vehiclesOnRoad : 0.02;
          var stoppedRatio =
            vehiclesOnRoad > 0 ? stoppedVehicles / vehiclesOnRoad : 0;

          // Determine congestion level (0 = free, 1 = light, 2 = moderate, 3 = heavy, 4 = severe)
          var congestionLevel = 0;

          if (stoppedRatio > 0.7 || vehicleDensity > 8) {
            congestionLevel = 4; // Severe congestion (dark red)
          } else if (stoppedRatio > 0.4 || vehicleDensity > 5) {
            congestionLevel = 3; // Heavy congestion (red)
          } else if (stoppedRatio > 0.2 || vehicleDensity > 3) {
            congestionLevel = 2; // Moderate congestion (yellow)
          } else if (vehicleDensity > 1.5) {
            congestionLevel = 1; // Light congestion (orange)
          } else {
            congestionLevel = 0; // Free flow (green)
          }

          // Store congestion level
          roadCongestionLevels[roadId] = {
            level: congestionLevel,
            density: vehicleDensity,
            avgSpeed: avgSpeed,
            stoppedRatio: stoppedRatio,
            vehicleCount: vehiclesOnRoad,
          };

          // Update road color based on congestion level
          var roadColor;
          var roadWeight = 3;

          switch (congestionLevel) {
            case 4: // Severe congestion
              roadColor = "#8B0000"; // Dark red
              roadWeight = 5;
              break;
            case 3: // Heavy congestion
              roadColor = "#FF0000"; // Red
              roadWeight = 4;
              break;
            case 2: // Moderate congestion
              roadColor = "#FFA500"; // Orange/Yellow
              roadWeight = 4;
              break;
            case 1: // Light congestion
              roadColor = "#FFFF00"; // Yellow
              roadWeight = 3;
              break;
            default: // Free flow
              roadColor = "#00FF00"; // Green
              roadWeight = 3;
          }

          // Update the road layer color
          if (road.layer) {
            road.layer.setStyle({
              color: roadColor,
              weight: roadWeight,
              opacity: 0.8,
            });
          }
        });
      }

      // Get road congestion level for a vehicle's current road
      function getRoadCongestionLevel(roadIndex) {
        var roadId = `road_${roadIndex}`;
        return (
          roadCongestionLevels[roadId] || {
            level: 0,
            density: 0,
            avgSpeed: 0.02,
          }
        );
      }

      // Simple fallback vehicle movement
      function updateVehicleAgentsBasic() {
        if (vehicles.length === 0) return;

        const batchSize = Math.min(50, Math.ceil(vehicles.length / 3));
        const startIndex = (updateCounter * batchSize) % vehicles.length;
        const endIndex = Math.min(startIndex + batchSize, vehicles.length);
        const updates = [];

        for (let i = startIndex; i < endIndex; i++) {
          const vehicle = vehicles[i];
          if (Math.random() < 0.2) continue;

          const roadCongestion = getRoadCongestionLevel(vehicle.roadIndex);
          let speedMultiplier = 1.0;

          switch (roadCongestion.level) {
            case 4:
              speedMultiplier *= 0.1;
              break;
            case 3:
              speedMultiplier *= 0.3;
              break;
            case 2:
              speedMultiplier *= 0.6;
              break;
            case 1:
              speedMultiplier *= 0.8;
              break;
            default:
              speedMultiplier *= 1.5;
              break;
          }

          const finalSpeed = vehicle.baseSpeed * speed * speedMultiplier;
          vehicle.pos += finalSpeed;

          if (vehicle.pos > 1) {
            vehicle.pos = 0;
          }

          const newPoint = getPointAlongLine(vehicle.path, vehicle.pos);
          if (newPoint) {
            const laneOffset = vehicle.lane === "left" ? -0.0001 : 0.0001;
            newPoint[1] += laneOffset;
            updates.push({ vehicle: vehicle, point: newPoint });
          }
        }

        updates.forEach((update) => {
          update.vehicle.marker.setLatLng(update.point);
        });
      }

      // Enhanced Realistic Vehicle Movement System with AI and Pathfinding
      async function updateVehicleAgents() {
        if (vehicles.length === 0) return;

        // Use basic movement if realistic movement is disabled
        if (!useRealisticMovement) {
          updateVehicleAgentsBasic();
          return;
        }

        const now = Date.now();
        const batchSize = Math.min(30, Math.ceil(vehicles.length / 4)); // Optimized batches
        const startIndex = (updateCounter * batchSize) % vehicles.length;
        const endIndex = Math.min(startIndex + batchSize, vehicles.length);
        const updates = [];

        for (let i = startIndex; i < endIndex; i++) {
          const vehicle = vehicles[i];

          // Skip some updates for performance (20% skip rate)
          if (Math.random() < 0.2) continue;

          const currentPos = vehicle.marker.getLatLng();
          const currentPosArray = [currentPos.lat, currentPos.lng];

          // Update vehicle state
          vehicle.lastUpdate = now;

          // Check if vehicle has reached its destination
          if (!vehicle.hasReachedDestination && vehicle.destination) {
            const distanceToDestination = calculateDistance(
              currentPosArray,
              vehicle.destination
            );
            if (distanceToDestination < 0.001) {
              // Within 100m of destination
              vehicle.hasReachedDestination = true;
              vehicle.stoppedTime = now;
              // Generate new destination after a brief stop
              setTimeout(() => {
                vehicle.destination =
                  generateRandomDestination(currentPosArray);
                vehicle.route = findRoute(currentPosArray, vehicle.destination);
                vehicle.hasReachedDestination = false;
                vehicle.currentRouteIndex = 0;
              }, 2000 + Math.random() * 5000); // Stop for 2-7 seconds
            }
          }

          // Skip movement if stopped at destination
          if (vehicle.hasReachedDestination) {
            continue;
          }

          // Get traffic conditions for AI decision making
          const nearbyLight = findNearestTrafficLight(currentPos);
          const roadCongestion = getRoadCongestionLevel(vehicle.roadIndex);

          const trafficConditions = {
            congestion: roadCongestion.level,
            lightState:
              nearbyLight && nearbyLight.distance < 0.008
                ? nearbyLight.light.state
                : "none",
            density: roadCongestion.density || 0,
          };

          // AI-enhanced decision making
          let aiDecision = {
            decision: "normal",
            speedUp: false,
            wait: false,
            changeRoute: false,
          };
          if (updateCounter % 10 === 0) {
            // Make AI decisions less frequently for performance
            aiDecision = await makeAIRoutingDecision(
              vehicle,
              currentPosArray,
              trafficConditions
            );
          }

          // Calculate movement speed based on multiple factors
          let speedMultiplier = 1.0;
          let baseSpeed = vehicle.baseSpeed * speed;

          // Road congestion impact (primary factor)
          switch (roadCongestion.level) {
            case 4:
              speedMultiplier *= 0.05;
              break; // Severe congestion - nearly stopped
            case 3:
              speedMultiplier *= 0.2;
              break; // Heavy congestion
            case 2:
              speedMultiplier *= 0.5;
              break; // Moderate congestion
            case 1:
              speedMultiplier *= 0.75;
              break; // Light congestion
            default:
              speedMultiplier *= 1.3;
              break; // Free flow
          }

          // Traffic light behavior with realistic compliance
          if (nearbyLight && nearbyLight.distance < 0.008) {
            vehicle.isAtIntersection = true;

            if (nearbyLight.light.state === "red") {
              const compliance = vehicle.routeKnowledge === "good" ? 0.8 : 0.6;
              if (Math.random() < compliance || vehicle.patience < 30) {
                speedMultiplier *= 0.1; // Stop or slow significantly
                vehicle.waitingAtLight = true;
                vehicle.stoppedTime += 100; // Increase frustration
              } else {
                speedMultiplier *= 0.6; // Some run red lights
              }
            } else if (nearbyLight.light.state === "yellow") {
              if (vehicle.drivingStyle.aggression > 0.6) {
                speedMultiplier *= 1.4; // Aggressive drivers speed up
              } else {
                speedMultiplier *= 0.4; // Cautious drivers slow down
              }
            } else {
              speedMultiplier *= 1.2; // Speed up on green
              vehicle.waitingAtLight = false;
            }
          } else {
            vehicle.isAtIntersection = false;
            vehicle.waitingAtLight = false;
          }

          // Vehicle type specific behavior
          const typeMultiplier = {
            bike: 1.5,
            motorcycle: 1.6,
            scooter: 1.4,
            car: 1.0,
            taxi: 1.1,
            auto: 1.2,
            bus: 0.7,
            truck: 0.6,
          };
          speedMultiplier *= typeMultiplier[vehicle.type] || 1.0;

          // Two-wheeler advantage in congestion (can weave through traffic)
          if (
            (vehicle.type === "bike" ||
              vehicle.type === "motorcycle" ||
              vehicle.type === "scooter") &&
            roadCongestion.level > 2
          ) {
            speedMultiplier *= 2.0; // Two-wheelers navigate congestion better
          }

          // AI decision influence
          if (aiDecision.speedUp && roadCongestion.level < 3) {
            speedMultiplier *= 1.3;
          } else if (aiDecision.wait) {
            speedMultiplier *= 0.3;
          }

          // Driving style influence
          speedMultiplier *=
            0.7 + vehicle.drivingStyle.speedVariance * Math.random();
          speedMultiplier *= 0.8 + vehicle.aggressiveness * 0.4;

          // Patience factor (frustrated drivers are more aggressive)
          if (vehicle.stoppedTime > 5000) {
            // Stopped for more than 5 seconds
            speedMultiplier *= 1 + vehicle.aggressiveness * 0.5;
            vehicle.patience = Math.max(0, vehicle.patience - 1);
          } else {
            vehicle.patience = Math.min(100, vehicle.patience + 0.1);
          }

          // Lane changing behavior
          if (Math.random() < vehicle.drivingStyle.laneChangeFreq) {
            vehicle.lane = vehicle.lane === "left" ? "right" : "left";
          }

          // Apply final speed
          const finalSpeed = baseSpeed * speedMultiplier;

          // Enhanced movement with route following
          if (
            vehicle.route &&
            vehicle.route.length > 1 &&
            !vehicle.hasReachedDestination
          ) {
            // Follow the planned route
            updateVehicleAlongRoute(vehicle, finalSpeed, updates);
          } else {
            // Fallback to simple path following
            vehicle.pos += finalSpeed;
            if (vehicle.pos > 1) {
              vehicle.pos = 0;
              // Generate new route when looping
              vehicle.destination = generateRandomDestination(currentPosArray);
              vehicle.route = findRoute(currentPosArray, vehicle.destination);
              vehicle.currentRouteIndex = 0;
            }

            const newPoint = getPointAlongLine(vehicle.path, vehicle.pos);
            if (newPoint) {
              const laneOffset = vehicle.lane === "left" ? -0.0001 : 0.0001;
              newPoint[1] += laneOffset;
              updates.push({ vehicle: vehicle, point: newPoint });
            }
          }
        }

        // Apply all position updates
        updates.forEach((update) => {
          update.vehicle.marker.setLatLng(update.point);
        });
      }

      // Update vehicle movement along planned route
      function updateVehicleAlongRoute(vehicle, speed, updates) {
        if (!vehicle.route || vehicle.route.length < 2) return;

        vehicle.routeProgress += speed;

        // Check if we've completed current route segment
        if (vehicle.routeProgress >= 1.0) {
          vehicle.currentRouteIndex++;
          vehicle.routeProgress = 0;

          // Check if we've reached the end of the route
          if (vehicle.currentRouteIndex >= vehicle.route.length - 1) {
            vehicle.hasReachedDestination = true;
            return;
          }

          // Update to next road segment
          const currentNode = vehicle.route[vehicle.currentRouteIndex];
          const nextNode = vehicle.route[vehicle.currentRouteIndex + 1];

          if (currentNode && nextNode) {
            // Find the road segment between these nodes
            const roadSegment = findRoadSegmentBetweenNodes(
              currentNode,
              nextNode
            );
            if (roadSegment) {
              vehicle.currentRoadSegment = roadSegment;
            }
          }
        }

        // Calculate position along current road segment
        const newPoint = getPointAlongLine(
          vehicle.currentRoadSegment,
          vehicle.routeProgress
        );
        if (newPoint) {
          const laneOffset = vehicle.lane === "left" ? -0.0001 : 0.0001;
          newPoint[1] += laneOffset;
          updates.push({ vehicle: vehicle, point: newPoint });
        }
      }

      // Find road segment between two graph nodes
      function findRoadSegmentBetweenNodes(nodeA, nodeB) {
        // Look for connection data between nodes
        const nodeAConnections = roadGraph[nodeA.id] || [];
        const connection = nodeAConnections.find(
          (conn) =>
            conn.node[0] === nodeB.position[1] &&
            conn.node[1] === nodeB.position[0]
        );

        if (connection) {
          // Create road segment from connection data
          return [nodeA.position, nodeB.position];
        }

        // Fallback: direct line between nodes
        return [nodeA.position, nodeB.position];
      }

      function calculateAISpeed(nearbyLight, congestion, vehicle) {
        var baseSpeed = vehicle.speed; // Use vehicle's actual speed
        var speedFactor = 1.0;

        // Indian traffic behavior - less strict traffic light compliance
        if (nearbyLight && nearbyLight.distance < 0.005) {
          if (nearbyLight.light.state === "red") {
            // Only 70% stop completely, others slow down but may proceed
            if (Math.random() < 0.7) {
              speedFactor = 0.2; // Slow down but not complete stop
            } else {
              speedFactor = 0.8; // Some vehicles ignore red lights
            }
          } else if (nearbyLight.light.state === "yellow") {
            // Most accelerate through yellow
            speedFactor = Math.random() < 0.8 ? 1.2 : 0.5;
          }
        }

        // Aggressive overtaking in congestion
        if (congestion > 3) {
          // Heavy congestion - some vehicles find gaps
          if (vehicle.type === "bike") {
            speedFactor *= 1.5; // Bikes weave through traffic
          } else {
            speedFactor *= 0.3;
          }
        } else if (congestion > 1) {
          speedFactor *= vehicle.type === "bike" ? 1.2 : 0.6;
        }

        // Aggressive driving factor
        speedFactor *= vehicle.aggressiveness;

        // Random speed variation (Indian driving style)
        speedFactor *= 0.7 + Math.random() * 0.8; // More variation

        return Math.max(0.001, baseSpeed * speedFactor);
      }

      function findNearestTrafficLight(position) {
        var nearest = null;
        var minDistance = Infinity;

        Object.values(trafficLights).forEach((light) => {
          var distance = Math.sqrt(
            Math.pow(position.lat - light.position[0], 2) +
              Math.pow(position.lng - light.position[1], 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearest = { light: light, distance: distance };
          }
        });

        return nearest;
      }

      function analyzeRoadCongestion(path) {
        var congestion = 0;
        var pathRadius = 0.001;

        vehicles.forEach((otherVehicle) => {
          var otherPos = otherVehicle.marker.getLatLng();
          for (var i = 0; i < path.length - 1; i++) {
            var segmentDistance = distanceToLineSegment(
              [otherPos.lat, otherPos.lng],
              path[i],
              path[i + 1]
            );
            if (segmentDistance < pathRadius) {
              congestion++;
              break;
            }
          }
        });

        return congestion;
      }

      function distanceToLineSegment(point, lineStart, lineEnd) {
        var A = point[0] - lineStart[0];
        var B = point[1] - lineStart[1];
        var C = lineEnd[0] - lineStart[0];
        var D = lineEnd[1] - lineStart[1];

        var dot = A * C + B * D;
        var lenSq = C * C + D * D;

        if (lenSq === 0) return Math.sqrt(A * A + B * B);

        var param = dot / lenSq;
        var xx, yy;

        if (param < 0) {
          xx = lineStart[0];
          yy = lineStart[1];
        } else if (param > 1) {
          xx = lineEnd[0];
          yy = lineEnd[1];
        } else {
          xx = lineStart[0] + param * C;
          yy = lineStart[1] + param * D;
        }

        var dx = point[0] - xx;
        var dy = point[1] - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      var updateCounter = 0;
      var lastPerformanceCheck = Date.now();
      var fps = 0;
      var performanceWarnings = 0;
      var maxVehicles = 2000; // Increased limit for realistic traffic density
      var predictionCount = 0;
      var lastAIConfidence = 0.5;

      // Main simulation update with Neural Network
      async function updateSimulation() {
        if (!isPlaying) return;

        var now = Date.now();
        updateCounter++;

        // Synchronized Traffic Light Management (every frame)
        synchronizeTrafficLights();

        // AI Vehicle Agent Updates (every frame but optimized)
        updateVehicleAgents();

        // Update road congestion colors every 20 frames (for performance)
        if (updateCounter % 20 === 0) {
          updateRoadCongestion();
        }

        // Performance monitoring and auto-optimization
        if (updateCounter % 50 === 0) {
          // Every 50 frames
          var elapsed = now - lastPerformanceCheck;
          fps = Math.round(50000 / elapsed);
          lastPerformanceCheck = now;

          // Auto-reduce complexity if performance is poor
          if (fps < 5 && vehicles.length > 100) {
            performanceWarnings++;
            if (performanceWarnings > 3) {
              var removeCount = Math.floor(vehicles.length * 0.3); // Remove 30%
              for (var r = 0; r < removeCount; r++) {
                var vehicle = vehicles.pop();
                if (vehicle && vehicle.marker) {
                  vehiclesLayer.removeLayer(vehicle.marker);
                }
              }
              maxVehicles = vehicles.length;
              updateLog(
                `<div class="error">‚ö†Ô∏è Auto-reduced vehicles to ${vehicles.length} for performance</div>`
              );
              performanceWarnings = 0;
            }
          } else if (fps > 15) {
            performanceWarnings = Math.max(0, performanceWarnings - 1);
          }

          // Collect data for neural network training
          if (!isTraining && updateCounter % 100 === 0) {
            // More frequent data collection
            collectTrafficData();
          }
        }

        // Neural network optimization every 200 frames (~20 seconds at 10fps)
        if (updateCounter % 200 === 0 && neuralNetwork && !isTraining) {
          var avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / (Object.keys(trafficLights).length || 1);

          var prediction = await predictOptimalTiming(
            avgDensity,
            2,
            30,
            new Date().getHours(),
            1.0,
            vehicles.length
          );

          // Track AI predictions and confidence
          predictionCount++;
          if (prediction.aiConfidence !== undefined) {
            lastAIConfidence = prediction.aiConfidence;
          }

          // Apply neural network recommendations to sync timing
          if (prediction.flow > 0.7) {
            globalPhaseOffset += prediction.sync;
          }

          // Update AI confidence display
          if (updateCounter % 100 === 0) {
            document.getElementById("confidence-value").textContent = `${(
              lastAIConfidence * 100
            ).toFixed(1)}%`;
            document.getElementById("prediction-count").textContent =
              predictionCount;

            // Update model type based on what's actually being used
            var modelType = window.transformersLoaded
              ? "TensorFlow"
              : "TensorFlow (Fallback)";
            document.getElementById("model-type").textContent = modelType;
          }
        }

        // Status update every 100 frames
        if (updateCounter % 100 === 0) {
          var avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / (Object.keys(trafficLights).length || 1);

          // Calculate congestion statistics
          var congestionStats = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
          var totalRoads = allRoads.length;

          Object.values(roadCongestionLevels).forEach((road) => {
            congestionStats[road.level]++;
          });

          var freeRoads = congestionStats[0];
          var congestedRoads = congestionStats[3] + congestionStats[4];

          updateLog(
            `üö¶ Traffic: ${avgDensity.toFixed(1)} density, ${
              vehicles.length
            } vehicles | Roads: ${freeRoads} green, ${
              congestionStats[1]
            } yellow, ${
              congestionStats[2]
            } orange, ${congestedRoads} red | ${fps} fps`
          );
        }
      }

      // Helper functions
      function getPointAlongLine(path, fraction) {
        if (!path || path.length < 2) return null;
        fraction = Math.max(0, Math.min(1, fraction));
        if (fraction === 0) return path[0];
        if (fraction === 1) return path[path.length - 1];

        var totalLength = calculatePathLength(path);
        var targetLength = totalLength * fraction;
        var cumulativeLength = 0;

        for (var i = 1; i < path.length; i++) {
          var segmentLength = dist(path[i - 1], path[i]);
          if (cumulativeLength + segmentLength >= targetLength) {
            var ratio = (targetLength - cumulativeLength) / segmentLength;
            return [
              path[i - 1][0] + ratio * (path[i][0] - path[i - 1][0]),
              path[i - 1][1] + ratio * (path[i][1] - path[i - 1][1]),
            ];
          }
          cumulativeLength += segmentLength;
        }
        return path[path.length - 1];
      }

      function calculatePathLength(path) {
        var length = 0;
        for (var i = 1; i < path.length; i++) {
          length += dist(path[i - 1], path[i]);
        }
        return length;
      }

      function dist(p1, p2) {
        return Math.sqrt(
          Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2)
        );
      }

      function updateLog(message) {
        var logElement = document.getElementById("log");
        var timestamp = new Date().toLocaleTimeString();

        // If message contains HTML, use innerHTML, otherwise use textContent
        if (message.includes("<div")) {
          logElement.innerHTML = `[${timestamp}] ${message}`;
        } else {
          logElement.innerHTML =
            `<div>[${timestamp}] ${message}</div>` + logElement.innerHTML;

          // Keep only last 10 log entries for performance
          var entries = logElement.children;
          while (entries.length > 10) {
            logElement.removeChild(entries[entries.length - 1]);
          }
        }

        // Auto-scroll to top
        logElement.scrollTop = 0;
      }

      // Event listeners
      document.getElementById("speed").addEventListener("input", function (e) {
        speed = parseFloat(e.target.value);
      });

      document
        .getElementById("geojsonInput")
        .addEventListener("change", function (e) {
          var file = e.target.files[0];
          if (file) {
            loadGeoJSON(file);
          }
        });

      document.getElementById("play").addEventListener("click", function () {
        startSimulation();
      });

      function startSimulation() {
        if (!isPlaying) {
          isPlaying = true;
          simulationInterval = setInterval(updateSimulation, 100); // Faster updates for realistic traffic (100ms)
          updateLog("‚ñ∂Ô∏è Realistic traffic simulation started");
        }
      }

      // WebGL Context Recovery
      function handleWebGLContextLoss() {
        updateLog(
          '<div class="error">‚ö†Ô∏è WebGL context lost - reducing simulation complexity</div>'
        );

        // Drastically reduce vehicle count
        if (vehicles.length > 200) {
          var keepVehicles = vehicles.slice(0, 200);
          vehicles.slice(200).forEach(function (vehicle) {
            vehiclesLayer.removeLayer(vehicle.marker);
          });
          vehicles = keepVehicles;
          updateLog(`Reduced vehicles to ${vehicles.length} for stability`);
        }

        // Slow down the simulation even more
        if (simulationInterval) {
          clearInterval(simulationInterval);
          simulationInterval = setInterval(updateSimulation, 500); // Very slow
        }
      }

      // Monitor for WebGL errors
      window.addEventListener("error", function (e) {
        if (e.message && e.message.includes("WebGL")) {
          handleWebGLContextLoss();
        }
      });

      document.getElementById("pause").addEventListener("click", function () {
        isPlaying = false;
        clearInterval(simulationInterval);
      });

      document.getElementById("reset").addEventListener("click", function () {
        if (simulationInterval) clearInterval(simulationInterval);
        isPlaying = false;
        vehicles.forEach((v) => (v.pos = Math.random()));
        globalPhaseOffset = 0;
        updateLog("Simulation reset");
      });

      document
        .getElementById("reduceVehicles")
        .addEventListener("click", function () {
          if (vehicles.length > 50) {
            var removeCount = Math.floor(vehicles.length * 0.5); // Remove 50%
            for (var r = 0; r < removeCount; r++) {
              var vehicle = vehicles.pop();
              if (vehicle && vehicle.marker) {
                vehiclesLayer.removeLayer(vehicle.marker);
              }
            }
            maxVehicles = vehicles.length;
            updateLog(`üöó Manually reduced vehicles to ${vehicles.length}`);
          }
        });

      document
        .getElementById("collectData")
        .addEventListener("click", function () {
          updateLog("üìä Fast data collection started...");

          // Collect 20 samples quickly
          for (var i = 0; i < 20; i++) {
            setTimeout(function () {
              collectTrafficData();
            }, i * 100); // Collect every 100ms
          }

          setTimeout(function () {
            updateLog(
              `‚úÖ Fast collection complete. Total samples: ${trafficData.length}`
            );
          }, 2100);
        });

      document.getElementById("trainNN").addEventListener("click", function () {
        trainNeuralNetwork();
      });

      document
        .getElementById("toggleRealistic")
        .addEventListener("click", function () {
          useRealisticMovement = !useRealisticMovement;
          const button = document.getElementById("toggleRealistic");
          if (useRealisticMovement) {
            button.textContent = "üöó Enhanced AI Movement (ON)";
            button.style.backgroundColor = "#4CAF50";
            updateLog(
              "‚úÖ Enhanced AI vehicle movement activated - vehicles now use pathfinding and realistic behavior"
            );
          } else {
            button.textContent = "üöó Basic Movement (OFF)";
            button.style.backgroundColor = "#f44336";
            updateLog(
              "‚ö†Ô∏è Switched to basic vehicle movement - simple path following"
            );
          }
        });

      // Initialize Neural Network on page load
      window.addEventListener("load", function () {
        initNeuralNetwork();
      });
    </script>
  </body>
</html>
