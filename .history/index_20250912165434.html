<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Simulation - Bhubaneswar</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
      #map {
        height: 600px;
        width: 100%;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      h1 {
        text-align: center;
      }
      #controls {
        text-align: center;
        margin: 10px;
      }
      #neural-status {
        background: #f0f0f0;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
      }
      #log {
        background: #f9f9f9;
        padding: 10px;
        margin: 10px;
        border-radius: 5px;
        max-height: 150px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 12px;
        border: 1px solid #ddd;
      }
      .vehicle-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .traffic-light-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .intersection-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
      }
      .loading {
        text-align: center;
        padding: 20px;
        background: #e8f4fd;
        border-radius: 5px;
        margin: 10px;
      }
      .error {
        background: #ffe6e6;
        border: 1px solid #ff9999;
        color: #cc0000;
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
      .success {
        background: #e6ffe6;
        border: 1px solid #99ff99;
        color: #006600;
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <h1>AI Traffic Simulation System for Bhubaneswar</h1>
    <div id="map"></div>
    <div id="controls">
      <input type="file" id="geojsonInput" accept=".geojson" /><label
        >Upload GeoJSON File</label
      ><br />
      <label
        >Simulation Speed:
        <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1"
      /></label>
      <button id="play">Play</button>
      <button id="pause">Pause</button>
      <button id="reset">Reset</button>
      <button id="reduceVehicles">Reduce Vehicles</button>
      <button id="collectData">Collect Data</button>
      <button id="trainNN">Train Neural Network</button>
    </div>
    <div id="neural-status">Neural Network Status: Initializing...</div>
    <div id="log">Simulation Log:</div>
    <script>
      var map = L.map("map").setView([20.272, 85.824], 13); // Bhubaneswar center
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      }).addTo(map);

      var roadsLayer = L.layerGroup().addTo(map);
      var intersectionsLayer = L.layerGroup().addTo(map);
      var vehiclesLayer = L.layerGroup().addTo(map);

      var allRoads = [];
      var allIntersections = [];
      var trafficLights = {};
      var vehicles = [];
      var simulationInterval;
      var isPlaying = false;
      var speed = 1;

      // Neural Network for Traffic Management
      var neuralNetwork = null;
      var trafficData = [];
      var isTraining = false;

      // Initialize Neural Network
      async function initNeuralNetwork() {
        try {
          // Create a simple neural network for traffic optimization
          neuralNetwork = tf.sequential({
            layers: [
              tf.layers.dense({
                inputShape: [6],
                units: 16,
                activation: "relu",
              }),
              tf.layers.dropout({ rate: 0.2 }),
              tf.layers.dense({ units: 8, activation: "relu" }),
              tf.layers.dense({ units: 4, activation: "sigmoid" }), // Output: [green_time, sync_offset, priority, flow_rate]
            ],
          });

          neuralNetwork.compile({
            optimizer: tf.train.adam(0.001),
            loss: "meanSquaredError",
            metrics: ["mae"],
          });

          document.getElementById("neural-status").textContent =
            "Neural Network Status: Ready";
          console.log("Neural network initialized successfully");
        } catch (error) {
          console.error("Failed to initialize neural network:", error);
          document.getElementById("neural-status").textContent =
            "Neural Network Status: Error - " + error.message;
        }
      }

      // Traffic Light Synchronization System
      var syncGroups = {};
      var globalPhaseOffset = 0;

      function createSyncGroups() {
        // Group nearby traffic lights for synchronization
        var lightPositions = Object.keys(trafficLights).map((key) => ({
          key: key,
          pos: trafficLights[key].position,
          light: trafficLights[key],
        }));

        var groupId = 0;
        lightPositions.forEach((light1, i) => {
          if (!light1.light.syncGroup) {
            var group = [light1];
            light1.light.syncGroup = groupId;

            // Find nearby lights within 0.01 degrees
            lightPositions.forEach((light2, j) => {
              if (i !== j && !light2.light.syncGroup) {
                var distance = Math.sqrt(
                  Math.pow(light1.pos[0] - light2.pos[0], 2) +
                    Math.pow(light1.pos[1] - light2.pos[1], 2)
                );

                if (distance < 0.01) {
                  // Within sync range
                  group.push(light2);
                  light2.light.syncGroup = groupId;
                }
              }
            });

            syncGroups[groupId] = group;
            groupId++;
          }
        });
      }

      function synchronizeTrafficLights() {
        globalPhaseOffset += 0.1 * speed;

        Object.values(syncGroups).forEach((group, groupIndex) => {
          var groupPhase = (globalPhaseOffset + groupIndex * 20) % 80; // 80 second cycle

          group.forEach((lightObj, index) => {
            var light = lightObj.light;
            var phaseDelay = index * 5; // 5 second delay between lights in group
            var lightPhase = (groupPhase + phaseDelay) % 80;

            // Update light state based on synchronized phase
            var newState;
            var newIcon;

            if (lightPhase < 30) {
              newState = "green";
              newIcon = L.divIcon({
                html: "🟢",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            } else if (lightPhase < 35) {
              newState = "yellow";
              newIcon = L.divIcon({
                html: "🟡",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            } else {
              newState = "red";
              newIcon = L.divIcon({
                html: "🔴",
                className: "traffic-light-icon",
                iconSize: [25, 25],
                iconAnchor: [12, 12],
              });
            }

            if (light.state !== newState) {
              light.state = newState;
              light.marker.setIcon(newIcon);
            }
          });
        });
      }

      // Neural Network Prediction for Traffic Optimization
      async function predictOptimalTiming(
        density,
        congestion,
        avgSpeed,
        timeOfDay,
        weatherFactor,
        historicalFlow
      ) {
        if (!neuralNetwork)
          return { green: 30, sync: 0, priority: 0.5, flow: 1.0 };

        try {
          const input = tf.tensor2d([
            [
              density / 10,
              congestion / 5,
              avgSpeed / 50,
              timeOfDay / 24,
              weatherFactor,
              historicalFlow / 100,
            ],
          ]);
          const prediction = neuralNetwork.predict(input);
          const result = await prediction.data();

          input.dispose();
          prediction.dispose();

          return {
            green: Math.max(15, Math.min(60, result[0] * 60)), // 15-60 seconds
            sync: result[1] * 10, // 0-10 second offset
            priority: result[2], // 0-1 priority factor
            flow: result[3], // 0-1 flow efficiency
          };
        } catch (error) {
          console.error("Neural network prediction error:", error);
          return { green: 30, sync: 0, priority: 0.5, flow: 1.0 };
        }
      }

      // Collect training data
      function collectTrafficData() {
        if (trafficData.length > 1000) trafficData.shift(); // Keep last 1000 records

        var avgDensity = 0;
        var lightCount = Object.keys(trafficLights).length;

        if (lightCount > 0) {
          avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / lightCount;
        }

        var avgCongestion = 0;
        var avgSpeed = 25; // Default speed

        if (vehicles.length > 0) {
          // Simplified congestion calculation for performance
          avgCongestion = Math.min(5, vehicles.length / 50); // Estimate based on vehicle density
          avgSpeed =
            vehicles.reduce((sum, v) => sum + v.speed * 1000, 0) /
            vehicles.length;
        }

        var timeOfDay = new Date().getHours();
        var weatherFactor = 1.0; // Could be dynamic based on weather API
        var historicalFlow = vehicles.length;

        // Calculate efficiency (lower density and congestion = higher efficiency)
        var efficiency = Math.max(0.1, 1 - avgDensity / 10 - avgCongestion / 8);

        // More realistic target values based on current conditions
        var optimalGreen = Math.max(0.3, Math.min(0.9, 0.4 + avgDensity / 15));
        var optimalSync = Math.random() * 0.6 + 0.2; // 0.2 to 0.8
        var optimalPriority = Math.max(0.4, Math.min(0.9, efficiency + 0.1));

        trafficData.push({
          input: [
            avgDensity / 10,
            avgCongestion / 5,
            avgSpeed / 50,
            timeOfDay / 24,
            weatherFactor,
            historicalFlow / 100,
          ],
          output: [efficiency, optimalGreen, optimalSync, optimalPriority],
        });

        // Log data collection progress
        if (trafficData.length % 10 === 0) {
          updateLog(`📊 Collected ${trafficData.length} training samples`);
        }
      }

      // Generate training data quickly for demonstration
      function generateTrainingData() {
        updateLog("🧠 Generating training data...");

        // Generate synthetic training data based on current simulation state
        for (var i = trafficData.length; i < 100; i++) {
          var syntheticDensity = Math.random() * 10;
          var syntheticCongestion = Math.random() * 5;
          var syntheticSpeed = 20 + Math.random() * 30;
          var syntheticTimeOfDay = Math.random() * 24;
          var syntheticWeather = 0.8 + Math.random() * 0.4;
          var syntheticFlow = Math.random() * 100;

          // Calculate realistic efficiency based on conditions
          var efficiency = Math.max(
            0.1,
            1 - syntheticDensity / 15 - syntheticCongestion / 10
          );
          var optimalGreen = Math.min(0.9, 0.3 + syntheticDensity / 20);
          var optimalSync = Math.random() * 0.8;
          var optimalPriority = Math.min(0.9, efficiency + 0.1);

          trafficData.push({
            input: [
              syntheticDensity / 10,
              syntheticCongestion / 5,
              syntheticSpeed / 50,
              syntheticTimeOfDay / 24,
              syntheticWeather,
              syntheticFlow / 100,
            ],
            output: [efficiency, optimalGreen, optimalSync, optimalPriority],
          });
        }

        updateLog(`✅ Generated ${trafficData.length} training samples`);
      }

      // Train Neural Network
      async function trainNeuralNetwork() {
        // Prevent multiple concurrent training sessions
        if (isTraining) {
          updateLog(
            '<div class="error">⚠️ Training already in progress. Please wait...</div>'
          );
          return;
        }

        if (!neuralNetwork) {
          document.getElementById("neural-status").textContent =
            "Neural Network not initialized";
          return;
        }

        if (trafficData.length < 50) {
          updateLog(`📊 Current data: ${trafficData.length}/50 samples`);
          generateTrainingData(); // Generate data if we don't have enough
        }

        isTraining = true;

        // Update UI to show training in progress
        const trainButton = document.getElementById("trainNN");
        trainButton.textContent = "Training... ⏳";
        trainButton.disabled = true;

        document.getElementById("neural-status").textContent =
          "Training Neural Network...";
        updateLog("🧠 Starting neural network training...");

        try {
          // Validate training data
          if (trafficData.length === 0) {
            throw new Error("No training data available");
          }

          const inputs = tf.tensor2d(trafficData.map((d) => d.input));
          const outputs = tf.tensor2d(trafficData.map((d) => d.output));

          updateLog(`🎯 Training with ${trafficData.length} samples...`);

          await neuralNetwork.fit(inputs, outputs, {
            epochs: 30, // Reduced epochs for faster training
            batchSize: Math.min(10, Math.floor(trafficData.length / 4)), // Dynamic batch size
            validationSplit: 0.2,
            shuffle: true, // Shuffle data for better training
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                if (epoch % 5 === 0) {
                  // Update every 5 epochs
                  const progress = Math.round((epoch / 30) * 100);
                  document.getElementById(
                    "neural-status"
                  ).textContent = `Training: ${progress}% (Epoch ${epoch}/30, Loss: ${logs.loss.toFixed(
                    4
                  )})`;
                  updateLog(
                    `📈 Training progress: ${progress}% - Loss: ${logs.loss.toFixed(
                      4
                    )}`
                  );
                }
              },
              onTrainEnd: () => {
                updateLog("✅ Training completed successfully!");
              },
            },
          });

          // Clean up tensors to prevent memory leaks
          inputs.dispose();
          outputs.dispose();

          document.getElementById("neural-status").textContent =
            "Neural Network: Trained Successfully ✅";
          updateLog(
            '<div class="success">🎉 Neural Network training completed! AI optimization is now active.</div>'
          );
        } catch (error) {
          console.error("Training error:", error);
          let errorMessage = error.message;

          // Provide user-friendly error messages
          if (errorMessage.includes("fit() call is ongoing")) {
            errorMessage =
              "Another training session is already running. Please wait for it to complete.";
          } else if (errorMessage.includes("tensor")) {
            errorMessage =
              "Data format error. Please try collecting new training data.";
          }

          document.getElementById("neural-status").textContent =
            "Training Failed: " + errorMessage;
          updateLog(
            `<div class="error">❌ Training failed: ${errorMessage}</div>`
          );
        } finally {
          isTraining = false;

          // Reset UI
          const trainButton = document.getElementById("trainNN");
          trainButton.textContent = "Train Neural Network";
          trainButton.disabled = false;

          updateLog("🔄 Training session ended. Ready for new training.");
        }
      }

      function loadGeoJSON(urlOrFile) {
        // Clear existing data
        roadsLayer.clearLayers();
        intersectionsLayer.clearLayers();
        vehiclesLayer.clearLayers();
        allRoads = [];
        allIntersections = [];
        trafficLights = {};
        vehicles = [];
        syncGroups = {};

        // Show loading indicator
        updateLog('<div class="loading">🔄 Loading GeoJSON data...</div>');

        if (urlOrFile instanceof File) {
          var reader = new FileReader();
          reader.onload = function (e) {
            try {
              var data = JSON.parse(e.target.result);
              processGeoJSON(data);
            } catch (error) {
              console.error("Error parsing uploaded file:", error);
              updateLog(
                '<div class="error">❌ Error parsing uploaded file. Please check the file format.</div>'
              );
            }
          };
          reader.onerror = function () {
            updateLog(
              '<div class="error">❌ Error reading uploaded file.</div>'
            );
          };
          reader.readAsText(urlOrFile);
        } else {
          fetch(urlOrFile)
            .then((response) => {
              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                );
              }
              return response.json();
            })
            .then((data) => {
              updateLog(
                '<div class="success">✅ GeoJSON loaded successfully!</div>'
              );
              processGeoJSON(data);
            })
            .catch((error) => {
              console.error("Error loading GeoJSON:", error);
              updateLog(
                `<div class="error">❌ Error loading GeoJSON: ${error.message}</div>`
              );

              // Try to create a fallback simulation with demo data
              updateLog(
                '<div class="loading">🔄 Creating demo traffic simulation...</div>'
              );
              createDemoSimulation();
            });
        }
      }

      function createDemoSimulation() {
        // Create a simple demo road network for Bhubaneswar
        var demoRoads = [
          // Main roads around Bhubaneswar center
          [
            [20.272, 85.82],
            [20.275, 85.825],
            [20.278, 85.83],
          ],
          [
            [20.27, 85.815],
            [20.272, 85.82],
            [20.274, 85.825],
          ],
          [
            [20.268, 85.822],
            [20.27, 85.827],
            [20.272, 85.832],
          ],
          [
            [20.275, 85.818],
            [20.277, 85.823],
            [20.279, 85.828],
          ],
          [
            [20.265, 85.825],
            [20.268, 85.83],
            [20.271, 85.835],
          ],
        ];

        demoRoads.forEach((roadCoords, index) => {
          var road = L.polyline(roadCoords, { color: "#666", weight: 3 });
          roadsLayer.addLayer(road);
          allRoads.push({
            geometry: roadCoords,
            properties: {
              road_id: `demo_${index}`,
              highway: "primary",
              vehicle_count: Math.floor(Math.random() * 30) + 10,
            },
            layer: road,
          });

          // Add vehicles to demo road
          addVehiclesToRoad(roadCoords, {
            vehicle_count: Math.floor(Math.random() * 20) + 5,
          });

          // Add traffic light at midpoint
          if (Math.random() < 0.6) {
            addTrafficLight(roadCoords);
          }
        });

        createSyncGroups();
        updateLog(
          `<div class="success">✅ Demo simulation created: ${
            allRoads.length
          } roads, ${vehicles.length} vehicles, ${
            Object.keys(trafficLights).length
          } traffic lights</div>`
        );
        setTimeout(startSimulation, 1000); // Auto-start after 1 second
      }

      function processGeoJSON(data) {
        var roadCount = 0;
        var trafficLightCount = 0;
        var pointCount = 0;

        // Check what type of data we have
        var hasLineStrings = data.features.some(
          (f) => f.geometry.type === "LineString"
        );
        var hasPoints = data.features.some((f) => f.geometry.type === "Point");

        updateLog(
          `Processing ${data.features.length} features. LineStrings: ${hasLineStrings}, Points: ${hasPoints}`
        );

        if (!hasLineStrings && hasPoints) {
          // If we only have points, create synthetic roads between nearby points
          updateLog(
            "No LineString roads found. Creating synthetic road network from points..."
          );
          createSyntheticRoads(data.features);
          setTimeout(startSimulation, 1000); // Auto-start after 1 second
          return;
        }

        data.features.forEach((feature) => {
          if (
            feature.geometry.type === "LineString" &&
            feature.properties.highway &&
            feature.properties.road_id
          ) {
            var coords = feature.geometry.coordinates.map((c) => [c[1], c[0]]);
            var road = L.polyline(coords, { color: "gray", weight: 3 });
            roadsLayer.addLayer(road);
            allRoads.push({
              geometry: coords,
              properties: feature.properties,
              layer: road,
            });
            roadCount++;

            // Add vehicles to roads
            addVehiclesToRoad(coords, feature.properties);

            // Add traffic lights
            if (coords.length > 2 && Math.random() < 0.3) {
              addTrafficLight(coords);
              trafficLightCount++;
            }
          } else if (feature.geometry.type === "Point") {
            // Process traffic signals and intersections from point data
            processPointFeature(feature);
            pointCount++;
          }
        });

        // Create synchronization groups after loading all lights
        createSyncGroups();
        updateLog(
          `<div class="success">✅ Loaded ${roadCount} roads, ${pointCount} points, ${trafficLightCount} traffic lights (${
            Object.keys(syncGroups).length
          } sync groups), ${vehicles.length} vehicles</div>`
        );
        if (vehicles.length > 0) {
          setTimeout(startSimulation, 1000); // Auto-start if we have vehicles
        }
      }

      function createSyntheticRoads(pointFeatures) {
        var points = pointFeatures
          .filter(
            (f) =>
              f.geometry.type === "Point" && f.properties.road_id !== undefined
          )
          .map((f) => ({
            coords: [f.geometry.coordinates[1], f.geometry.coordinates[0]], // lat, lng
            properties: f.properties,
          }))
          .slice(0, 50); // Limit to 50 points for performance

        // Create roads between nearby points
        for (var i = 0; i < points.length; i++) {
          for (var j = i + 1; j < points.length; j++) {
            var distance = calculateDistance(
              points[i].coords,
              points[j].coords
            );
            if (distance < 0.02 && Math.random() < 0.3) {
              // 2km max distance, 30% chance
              var roadCoords = [points[i].coords, points[j].coords];
              var road = L.polyline(roadCoords, {
                color: "#666",
                weight: 2,
                opacity: 0.7,
              });
              roadsLayer.addLayer(road);
              allRoads.push({
                geometry: roadCoords,
                properties: {
                  road_id: `synthetic_${i}_${j}`,
                  highway: "synthetic",
                  vehicle_count: Math.floor(Math.random() * 50) + 10,
                },
                layer: road,
              });

              // Add vehicles to synthetic road
              addVehiclesToRoad(roadCoords, {
                vehicle_count: Math.floor(Math.random() * 20) + 5,
              });
            }
          }
        }

        // Add traffic lights at major intersections
        points.slice(0, 20).forEach((point) => {
          if (
            point.properties.highway === "traffic_signals" ||
            point.properties.junction === "yes" ||
            Math.random() < 0.4
          ) {
            addTrafficLightAtPoint(point.coords);
          }
        });

        updateLog(
          `<div class="success">✅ Created ${allRoads.length} synthetic roads from ${points.length} points with ${vehicles.length} vehicles</div>`
        );
        if (vehicles.length > 0) {
          setTimeout(startSimulation, 1000); // Auto-start if we have vehicles
        }
      }

      function addVehiclesToRoad(coords, properties) {
        var vehicleCount = properties.vehicle_count || 0;

        if (Math.random() < 0.5) {
          // Reduce to 50% of roads get vehicles
          var roadLength = calculatePathLength(coords);
          var vehiclesPerRoad = Math.min(
            8, // Reduced from 15 to 8 vehicles per road
            Math.max(1, Math.floor(roadLength * 40 + vehicleCount * 0.05)) // Reduced density
          );

          for (var v = 0; v < vehiclesPerRoad; v++) {
            var point = getPointAlongLine(coords, Math.random());
            if (point) {
              var vehicleTypes = [
                { icon: "🚗", speed: 0.004, type: "car", color: "#ff6b6b" },
                { icon: "🏍️", speed: 0.006, type: "bike", color: "#4ecdc4" },
                { icon: "🚌", speed: 0.003, type: "bus", color: "#45b7d1" },
                { icon: "🛺", speed: 0.005, type: "auto", color: "#f9ca24" },
                { icon: "🚚", speed: 0.0035, type: "truck", color: "#6c5ce7" },
                {
                  icon: "🛴",
                  speed: 0.0055,
                  type: "scooter",
                  color: "#a0e7e5",
                },
              ];

              var vehicleType = vehicleTypes[Math.floor(Math.random() * 6)];

              // Use simple circle markers instead of emoji icons for better performance
              var vehicleIcon = L.circleMarker(point, {
                radius: 3,
                fillColor: vehicleType.color,
                color: vehicleType.color,
                weight: 1,
                opacity: 0.8,
                fillOpacity: 0.6,
              });

              vehiclesLayer.addLayer(vehicleIcon);
              vehicles.push({
                marker: vehicleIcon,
                path: coords,
                pos: Math.random(),
                speed: vehicleType.speed * (0.8 + Math.random() * 0.4),
                type: vehicleType.type,
                aggressiveness: 0.5 + Math.random() * 0.5,
              });

              if (vehicles.length >= maxVehicles) break; // Dynamic limit for WebGL stability
            }
          }
        }
      }

      function addTrafficLight(coords) {
        var midPoint = coords[Math.floor(coords.length / 2)];
        addTrafficLightAtPoint(midPoint);
      }

      function addTrafficLightAtPoint(point) {
        var trafficLightIcon = L.divIcon({
          html: '<div style="font-size: 18px;">🚥</div>',
          className: "traffic-light-icon",
          iconSize: [25, 25],
          iconAnchor: [12, 12],
        });
        var light = L.marker(point, { icon: trafficLightIcon });
        intersectionsLayer.addLayer(light);
        trafficLights[point.join(",")] = {
          marker: light,
          state: "green",
          timer: 30 + Math.random() * 20,
          position: point,
          syncGroup: null,
        };
      }

      function processPointFeature(feature) {
        var coords = [
          feature.geometry.coordinates[1],
          feature.geometry.coordinates[0],
        ];

        if (feature.properties.highway === "traffic_signals") {
          addTrafficLightAtPoint(coords);
        } else if (feature.properties.junction === "yes") {
          // Add intersection marker
          var intersectionIcon = L.divIcon({
            html: '<div style="font-size: 16px;">⭕</div>',
            className: "intersection-icon",
            iconSize: [20, 20],
            iconAnchor: [10, 10],
          });
          var marker = L.marker(coords, { icon: intersectionIcon });
          intersectionsLayer.addLayer(marker);
        }
      }

      function calculateDistance(point1, point2) {
        var R = 6371; // Earth's radius in km
        var dLat = ((point2[0] - point1[0]) * Math.PI) / 180;
        var dLng = ((point2[1] - point1[1]) * Math.PI) / 180;
        var a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((point1[0] * Math.PI) / 180) *
            Math.cos((point2[0] * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      loadGeoJSON("bhubaneswar_traffic_flow.geojson");

      // Calculate traffic density around intersection
      function calculateTrafficDensity(position) {
        var density = 0;
        var radius = 0.01;

        vehicles.forEach((vehicle) => {
          var vehiclePos = vehicle.marker.getLatLng();
          var distance = Math.sqrt(
            Math.pow(position[0] - vehiclePos.lat, 2) +
              Math.pow(position[1] - vehiclePos.lng, 2)
          );
          if (distance < radius) {
            density++;
          }
        });
        return density;
      }

      // AI Vehicle Agent System - Ultra Optimized for WebGL stability
      function updateVehicleAgents() {
        if (vehicles.length === 0) return;

        // Update only a very small subset each frame to prevent WebGL context loss
        var batchSize = Math.min(20, Math.ceil(vehicles.length / 10)); // Reduced batch size
        var startIndex = (updateCounter * batchSize) % vehicles.length;
        var endIndex = Math.min(startIndex + batchSize, vehicles.length);

        // Use requestAnimationFrame for smoother updates
        var updates = [];

        for (var i = startIndex; i < endIndex; i++) {
          var vehicle = vehicles[i];

          // Skip some updates randomly to reduce load
          if (Math.random() < 0.3) continue; // Skip 70% of updates

          var currentPos = vehicle.marker.getLatLng();

          // Very simplified traffic light checking (much less frequent)
          var nearbyLight = null;
          if (updateCounter % 10 === 0 && Math.random() < 0.5) {
            nearbyLight = findNearestTrafficLight(currentPos);
          }

          // Simplified movement calculation
          var aiSpeed = vehicle.speed * speed * (0.8 + Math.random() * 0.4);

          vehicle.pos += aiSpeed;
          if (vehicle.pos > 1) {
            vehicle.pos = 0;
          }

          var newPoint = getPointAlongLine(vehicle.path, vehicle.pos);
          if (newPoint) {
            updates.push({ vehicle: vehicle, point: newPoint });
          }
        }

        // Batch DOM updates to prevent WebGL issues
        if (updates.length > 0) {
          requestAnimationFrame(function () {
            updates.forEach(function (update) {
              update.vehicle.marker.setLatLng(update.point);
            });
          });
        }
      }

      function calculateAISpeed(nearbyLight, congestion, vehicle) {
        var baseSpeed = vehicle.speed; // Use vehicle's actual speed
        var speedFactor = 1.0;

        // Indian traffic behavior - less strict traffic light compliance
        if (nearbyLight && nearbyLight.distance < 0.005) {
          if (nearbyLight.light.state === "red") {
            // Only 70% stop completely, others slow down but may proceed
            if (Math.random() < 0.7) {
              speedFactor = 0.2; // Slow down but not complete stop
            } else {
              speedFactor = 0.8; // Some vehicles ignore red lights
            }
          } else if (nearbyLight.light.state === "yellow") {
            // Most accelerate through yellow
            speedFactor = Math.random() < 0.8 ? 1.2 : 0.5;
          }
        }

        // Aggressive overtaking in congestion
        if (congestion > 3) {
          // Heavy congestion - some vehicles find gaps
          if (vehicle.type === "bike") {
            speedFactor *= 1.5; // Bikes weave through traffic
          } else {
            speedFactor *= 0.3;
          }
        } else if (congestion > 1) {
          speedFactor *= vehicle.type === "bike" ? 1.2 : 0.6;
        }

        // Aggressive driving factor
        speedFactor *= vehicle.aggressiveness;

        // Random speed variation (Indian driving style)
        speedFactor *= 0.7 + Math.random() * 0.8; // More variation

        return Math.max(0.001, baseSpeed * speedFactor);
      }

      function findNearestTrafficLight(position) {
        var nearest = null;
        var minDistance = Infinity;

        Object.values(trafficLights).forEach((light) => {
          var distance = Math.sqrt(
            Math.pow(position.lat - light.position[0], 2) +
              Math.pow(position.lng - light.position[1], 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearest = { light: light, distance: distance };
          }
        });

        return nearest;
      }

      function analyzeRoadCongestion(path) {
        var congestion = 0;
        var pathRadius = 0.001;

        vehicles.forEach((otherVehicle) => {
          var otherPos = otherVehicle.marker.getLatLng();
          for (var i = 0; i < path.length - 1; i++) {
            var segmentDistance = distanceToLineSegment(
              [otherPos.lat, otherPos.lng],
              path[i],
              path[i + 1]
            );
            if (segmentDistance < pathRadius) {
              congestion++;
              break;
            }
          }
        });

        return congestion;
      }

      function distanceToLineSegment(point, lineStart, lineEnd) {
        var A = point[0] - lineStart[0];
        var B = point[1] - lineStart[1];
        var C = lineEnd[0] - lineStart[0];
        var D = lineEnd[1] - lineStart[1];

        var dot = A * C + B * D;
        var lenSq = C * C + D * D;

        if (lenSq === 0) return Math.sqrt(A * A + B * B);

        var param = dot / lenSq;
        var xx, yy;

        if (param < 0) {
          xx = lineStart[0];
          yy = lineStart[1];
        } else if (param > 1) {
          xx = lineEnd[0];
          yy = lineEnd[1];
        } else {
          xx = lineStart[0] + param * C;
          yy = lineStart[1] + param * D;
        }

        var dx = point[0] - xx;
        var dy = point[1] - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      var updateCounter = 0;
      var lastPerformanceCheck = Date.now();
      var fps = 0;
      var performanceWarnings = 0;
      var maxVehicles = 1000; // Dynamic limit

      // Main simulation update with Neural Network
      async function updateSimulation() {
        if (!isPlaying) return;

        var now = Date.now();
        updateCounter++;

        // Synchronized Traffic Light Management (every frame)
        synchronizeTrafficLights();

        // AI Vehicle Agent Updates (every frame but optimized)
        updateVehicleAgents();

        // Performance monitoring and auto-optimization
        if (updateCounter % 50 === 0) {
          // Every 50 frames
          var elapsed = now - lastPerformanceCheck;
          fps = Math.round(50000 / elapsed);
          lastPerformanceCheck = now;

          // Auto-reduce complexity if performance is poor
          if (fps < 5 && vehicles.length > 100) {
            performanceWarnings++;
            if (performanceWarnings > 3) {
              var removeCount = Math.floor(vehicles.length * 0.3); // Remove 30%
              for (var r = 0; r < removeCount; r++) {
                var vehicle = vehicles.pop();
                if (vehicle && vehicle.marker) {
                  vehiclesLayer.removeLayer(vehicle.marker);
                }
              }
              maxVehicles = vehicles.length;
              updateLog(
                `<div class="error">⚠️ Auto-reduced vehicles to ${vehicles.length} for performance</div>`
              );
              performanceWarnings = 0;
            }
          } else if (fps > 15) {
            performanceWarnings = Math.max(0, performanceWarnings - 1);
          }

          // Collect data for neural network training
          if (!isTraining && updateCounter % 100 === 0) {
            // More frequent data collection
            collectTrafficData();
          }
        }

        // Neural network optimization every 200 frames (~20 seconds at 10fps)
        if (updateCounter % 200 === 0 && neuralNetwork && !isTraining) {
          var avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / (Object.keys(trafficLights).length || 1);

          var prediction = await predictOptimalTiming(
            avgDensity,
            2,
            30,
            new Date().getHours(),
            1.0,
            vehicles.length
          );

          // Apply neural network recommendations to sync timing
          if (prediction.flow > 0.7) {
            globalPhaseOffset += prediction.sync;
          }
        }

        // Status update every 100 frames
        if (updateCounter % 100 === 0) {
          var avgDensity =
            Object.values(trafficLights).reduce((sum, light) => {
              return sum + calculateTrafficDensity(light.position);
            }, 0) / (Object.keys(trafficLights).length || 1);

          updateLog(
            `Traffic Control: ${avgDensity.toFixed(1)} density, ${
              vehicles.length
            } vehicles, ${
              Object.keys(syncGroups).length
            } sync groups, ${fps} fps, ${trafficData.length} samples`
          );
        }
      }

      // Helper functions
      function getPointAlongLine(path, fraction) {
        if (!path || path.length < 2) return null;
        fraction = Math.max(0, Math.min(1, fraction));
        if (fraction === 0) return path[0];
        if (fraction === 1) return path[path.length - 1];

        var totalLength = calculatePathLength(path);
        var targetLength = totalLength * fraction;
        var cumulativeLength = 0;

        for (var i = 1; i < path.length; i++) {
          var segmentLength = dist(path[i - 1], path[i]);
          if (cumulativeLength + segmentLength >= targetLength) {
            var ratio = (targetLength - cumulativeLength) / segmentLength;
            return [
              path[i - 1][0] + ratio * (path[i][0] - path[i - 1][0]),
              path[i - 1][1] + ratio * (path[i][1] - path[i - 1][1]),
            ];
          }
          cumulativeLength += segmentLength;
        }
        return path[path.length - 1];
      }

      function calculatePathLength(path) {
        var length = 0;
        for (var i = 1; i < path.length; i++) {
          length += dist(path[i - 1], path[i]);
        }
        return length;
      }

      function dist(p1, p2) {
        return Math.sqrt(
          Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2)
        );
      }

      function updateLog(message) {
        var logElement = document.getElementById("log");
        var timestamp = new Date().toLocaleTimeString();

        // If message contains HTML, use innerHTML, otherwise use textContent
        if (message.includes("<div")) {
          logElement.innerHTML = `[${timestamp}] ${message}`;
        } else {
          logElement.innerHTML =
            `<div>[${timestamp}] ${message}</div>` + logElement.innerHTML;

          // Keep only last 10 log entries for performance
          var entries = logElement.children;
          while (entries.length > 10) {
            logElement.removeChild(entries[entries.length - 1]);
          }
        }

        // Auto-scroll to top
        logElement.scrollTop = 0;
      }

      // Event listeners
      document.getElementById("speed").addEventListener("input", function (e) {
        speed = parseFloat(e.target.value);
      });

      document
        .getElementById("geojsonInput")
        .addEventListener("change", function (e) {
          var file = e.target.files[0];
          if (file) {
            loadGeoJSON(file);
          }
        });

      document.getElementById("play").addEventListener("click", function () {
        startSimulation();
      });

      function startSimulation() {
        if (!isPlaying) {
          isPlaying = true;
          simulationInterval = setInterval(updateSimulation, 300); // Much slower for WebGL stability (300ms)
          updateLog("▶️ Simulation started");
        }
      }

      // WebGL Context Recovery
      function handleWebGLContextLoss() {
        updateLog(
          '<div class="error">⚠️ WebGL context lost - reducing simulation complexity</div>'
        );

        // Drastically reduce vehicle count
        if (vehicles.length > 200) {
          var keepVehicles = vehicles.slice(0, 200);
          vehicles.slice(200).forEach(function (vehicle) {
            vehiclesLayer.removeLayer(vehicle.marker);
          });
          vehicles = keepVehicles;
          updateLog(`Reduced vehicles to ${vehicles.length} for stability`);
        }

        // Slow down the simulation even more
        if (simulationInterval) {
          clearInterval(simulationInterval);
          simulationInterval = setInterval(updateSimulation, 500); // Very slow
        }
      }

      // Monitor for WebGL errors
      window.addEventListener("error", function (e) {
        if (e.message && e.message.includes("WebGL")) {
          handleWebGLContextLoss();
        }
      });

      document.getElementById("pause").addEventListener("click", function () {
        isPlaying = false;
        clearInterval(simulationInterval);
      });

      document.getElementById("reset").addEventListener("click", function () {
        if (simulationInterval) clearInterval(simulationInterval);
        isPlaying = false;
        vehicles.forEach((v) => (v.pos = Math.random()));
        globalPhaseOffset = 0;
        updateLog("Simulation reset");
      });

      document
        .getElementById("reduceVehicles")
        .addEventListener("click", function () {
          if (vehicles.length > 50) {
            var removeCount = Math.floor(vehicles.length * 0.5); // Remove 50%
            for (var r = 0; r < removeCount; r++) {
              var vehicle = vehicles.pop();
              if (vehicle && vehicle.marker) {
                vehiclesLayer.removeLayer(vehicle.marker);
              }
            }
            maxVehicles = vehicles.length;
            updateLog(`🚗 Manually reduced vehicles to ${vehicles.length}`);
          }
        });

      document
        .getElementById("collectData")
        .addEventListener("click", function () {
          updateLog("📊 Fast data collection started...");

          // Collect 20 samples quickly
          for (var i = 0; i < 20; i++) {
            setTimeout(function () {
              collectTrafficData();
            }, i * 100); // Collect every 100ms
          }

          setTimeout(function () {
            updateLog(
              `✅ Fast collection complete. Total samples: ${trafficData.length}`
            );
          }, 2100);
        });

      document.getElementById("trainNN").addEventListener("click", function () {
        trainNeuralNetwork();
      });

      // Initialize Neural Network on page load
      window.addEventListener("load", function () {
        initNeuralNetwork();
      });
    </script>
  </body>
</html>
